---
title: Sending and retrieving form data
slug: Learn/Forms/Sending_and_retrieving_form_data
translation_of: Learn/Forms/Sending_and_retrieving_form_data
original_slug: Learn/HTML/Forms/Sending_and_retrieving_form_data
---
<p><span style="line-height: 1.5;">많은 경우 HTML 폼은 서버에 데이터를 전송할 목적으로 사용된다. </span>서버는 데이터를 처리하고 사용자에게 응답을 보낼 것이다. 간단한 것 처럼 보이지만 데이터가 서버나 사용자에게 피해를 입히지 않기 위해서는 몇가지를 명심해야한다.</p>

<h2 id="데이터는_어디로_갈까">데이터는 어디로 갈까?</h2>

<h3 id="클라이언트서버_구조">클라이언트/서버 구조</h3>

<p><span style="line-height: 1.5;">웹은 간단히 말하면 클라이언트(파이어폭스, 크롬, 사파리, IE 등)는 서버(아파치, Nginx, IIS, 톰켓 등)로 HTTP프로토콜을 사용해 요청을 하는 클라이언트/서버 구조를 기본으로 작동된다.</span> 서버 응답은 요청과 똑같은 프로토콜을 사용한다.</p>

<p><img alt="A basic schema of the Web client/server architecture" src="/files/4291/client-server.png" style="height: 141px; width: 400px;"></p>

<p>클라이언트 측에서 HTML폼 만큼 사용친화적으로 HTTP 요청을 서버에 보내는 편리한 것이 없다.이것은 사용자가 정보를 HTTP요청으로 전달을 할 수있게 만든다.</p>

<h3 id="클라이언트측_데이터_보내기">클라이언트측: 데이터 보내기</h3>

<p><a href="/ko/docs/Web/HTML/Element/form" title="HTML &lt;form&gt; 요소는 정보를 제출하기 위한 대화형 컨트롤을 포함하는 문서 구획을 나타냅니다."><code>&lt;form&gt;</code></a> 요소는 데이터 전송 방법을 정의한다. 제공하는 모든 속성은 사용자가 submit 버튼을 누를때 보내질 요청을 구성할 수 있도록  설계되었다. 두가지 중요한 속성은 <code><a href="/ko/docs/Web/HTML/Element/form#attr-action">action</a></code> 와 <code><a href="/ko/docs/Web/HTML/Element/form#attr-method">method</a></code>이다.</p>

<h4 id="action_속성"><code><a href="/ko/docs/Web/HTML/Element/form#attr-action">action</a></code> 속성</h4>

<p>이 속성은 데이터를 어디로 보낼 것인지 지정한다. 이 값은 반드시 유효한 URL이어야 한다.만약 이 속성을 지정하지 않으면 데이터는 폼이 있는 페이지의 URL로 보내질 것이다.</p>

<h5 id="Examples">Examples</h5>

<p>첫번째 예제로 데이터는 http://foo.com로 보낼 것이다.</p>

<pre class="brush: html notranslate">&lt;form action=&quot;http://foo.com&quot;&gt;</pre>

<p class="brush: html">여기에서 데이터는 폼 페이지를 호스팅을 하는 같은 서버로 전송 되지만, 서버의  다른 URL로 전송된다.</p>

<pre class="brush: html notranslate">&lt;form action=&quot;/somewhere_else&quot;&gt;</pre>

<p class="brush: html">아래와 같이 속성을 지정하지 않으면 <a href="/ko/docs/Web/HTML/Element/form" title="HTML &lt;form&gt; 요소는 정보를 제출하기 위한 대화형 컨트롤을 포함하는 문서 구획을 나타냅니다."><code>&lt;form&gt;</code></a> 속성은 데이터를 폼을 포함한 페이지 주소로 보낼 것이다.</p>

<pre class="brush: html notranslate">&lt;form&gt;</pre>

<p class="brush: html">이전에 많은 페이지들은 데이터를 반드시 폼을 포함하는 페이지와 같은 페이지에 보내는 것을 나타내는 표기법을 다음과 같이 사용했다. 그러나 HTML5 이후로 속성은 필수로 지정하지 않아도 되기 떄문에 이제 더이상 필요하지 않는다.</p>

<pre class="brush: html notranslate">&lt;form action=&quot;#&quot;&gt;</pre>

<div class="note notecard">
<p><strong>Note: </strong>HTTPS(보안 HTTP) 프로토콜을 사용하는 URL을 지정하는 것도 가능하다. 이 것을 사용하면 폼 자체가 안전하지 않은 페이지에 HTTP를 이용해서 접근하는  곳에 호스트된 경우에 데이터는 나머지 요청들과 함께 암호화된다. <span style="line-height: 1.5;">반면, 만약 폼이 보안 페이지에서 호스트 된 경우라도 </span> <code><a href="/ko/docs/Web/HTML/Element/form#attr-action">action</a></code> 속성에서 <span style="line-height: 1.5;">안전하지 않은 HTTP URL을  지정하면 모든 브라우저는 데이터가 암호화되지 않았기 때문에 데이터를 보낼때마다 보안 경고를 출력할 것이다 </span></p>
</div>

<h4 id="method_속성"><code><a href="/ko/docs/Web/HTML/Element/form#attr-method">method</a></code> 속성</h4>

<p>이 속성은 데이터를 어떻게 보낼 것인지 정의한다. <a href="/en-US/docs/HTTP" title="/en-US/docs/HTTP">HTTP protocol</a> <span style="line-height: 1.5;">은 요청 방법에 대해 다양한 방법들을 제공한다.  HTML 폼 데이터는 오직 2가지 방법으로 만 전송 할 수 있는데 바로 GET 방식과 POST방식이 있다.</span></p>

<p>이 두 가지 방식의 차이점을 이해하기 위해서는 뒤로 가서 HTTP가 어떻게 작동하는지 살펴봐야한다. 웹에서 리소스에 접근 할 때마다, 브라우저는 URL에 요청을 보낸다. HTTP요청은 두 가지 부분으로 나누어진다. 브라우저 수용력에 대한 전역 메타 테이터들을 포함하는 헤더와 서버에서 지정된 요청을 처리하는데 필요한 정보를 포함하는 바디가 있다.</p>

<h5 id="GET_방식">GET 방식</h5>

<p><span style="line-height: 1.5;">GET 방식은 브라우저에서 서버에 주어진 리소스를 전달해달라고 말하기 위해 사용되는 방식이다. &quot; 이봐 서버 난 이 리소스를 원해&quot; 이 경우 브라우저는 바디가 비어 있는 요청을 하게 된다. </span>바디가 비어 있기 때문에,  만약 폼이 이 방식를 통하여 전송 하는 경우 데이터는 URL에 포함되어 서버로 보내진다.</p>

<h6 id="예제">예제</h6>

<p>다음 폼을 생각 해 봅시다.</p>

<pre class="brush: html notranslate">&lt;form action=&quot;http://foo.com&quot; method=&quot;get&quot;&gt;
  &lt;input name=&quot;say&quot; value=&quot;Hi&quot;&gt;
  &lt;input name=&quot;to&quot; value=&quot;Mom&quot;&gt;
  &lt;button&gt;Send my greetings&lt;/button&gt;
&lt;/form&gt;</pre>

<p>GET 방식을 사용하면 HTTP 요청은 다음과 같다.</p>

<pre class="notranslate">GET /?say=Hi&amp;to=Mom HTTP/1.1
Host: foo.com</pre>

<h5 id="POST_방식">POST 방식</h5>

<p><span style="line-height: 1.5;">POST 방식은 조금 다르다. </span>이는 브라우저의 HTTP요청 바디안에 제공되는 데이터를 고려한 응답을 요구하기 위해 서버로 보내는 방식이다. &quot;이봐 서버 이 데이터를 보고 이거에 맞는 데이터를 보내봐&quot; <span style="line-height: 1.5;">만약 폼이 이 방식으로 사용하여 요청을 한다면 데이터는 HTTP요청 바디에 추가되어 전송된다.</span></p>

<p>예제</p>

<p>이 폼을 생각해보라(위 예제와 똑같다)</p>

<pre class="brush: html notranslate">&lt;form action=&quot;http://foo.com&quot; method=&quot;post&quot;&gt;
  &lt;input name=&quot;say&quot; value=&quot;Hi&quot;&gt;
  &lt;input name=&quot;to&quot; value=&quot;Mom&quot;&gt;
  &lt;button&gt;Send my greetings&lt;/button&gt;
&lt;/form&gt;</pre>

<p>POST 방식을 사용하면 다음과 같이 HTTP 요청을 할 것이다,</p>

<pre class="notranslate">POST / HTTP/1.1
Host: foo.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 13

say=Hi&amp;to=Mom</pre>

<p>Content-Length 헤더는 바디의 크기를 나태내고,  Content-Type 헤더는 서버에 보낼 리소스의 종류 나태낸다. 우리는 비트(bit/조금씩?)에서 이러한 헤더를 설명 할 것이다.</p>

<p><span style="line-height: 1.5;">물론 http 요청은 절대 사용자에게 표시되지 않는다(파이어폭스 웹 콘솔이나 크롬 개발자 툴을 이용하지 않는이상). </span>사용자에게 보여지는 것은 호출한 URL뿐이다. <span style="line-height: 1.5;">그래서 GET 요청은 사용자에게 URL바에서 데이터를 볼 수있지만,  POST 요청은 그러지 못한다. 이것은 두가지 이유에서 매우 중요하다.</span></p>

<ol>
 <li>만약 패스워드를 전송해야 되는 경우(또는 민간한 데이터의 부분), 절대 URL 바에 데이터를 출력하는 GET 방식을 사용해서는 안된다.</li>
 <li>만약 거대한 데이터를 보내는경우 POST 방식이 선호 된다. 왜냐하면 몇몇 브라우저는 URL들의 크기를 제한하기 떄문이다. 또한 많은 서버들이 URL들의 길이를 제한한다.</li>
</ol>

<h3 id="서버측_데이터_가져오기">서버측: 데이터 가져오기</h3>

<p>어떠한 HTTP 방식을 선택 하든지 서버는 키/ 벨류 쌍의 목록과 같은 데이터를 얻기 위해 파싱된 문자열을 받을 것이다. 이러한 목록에 접근하는 방법은 사용하는 개발 플랫폼에 의존되고 어떠한 지정된 프레임워크에서 이것을 사용 할 수 있을것이다. 또한 사용 하는 기술은 동일한 키를 어떻게 처리할 것인지 결정한다. 보통 가장 마지막에 수신된 값이 우선순위를 가진다.</p>

<h4 id="예제_PHP_날것">예제: PHP 날것</h4>

<p>PHP 데이타에 접근 하기 위하여 몇가지 글로벌 객체를 제공한다. POST 방식 사용했다고 생각해보면, 다음과 같은 예제는 단순히 데이터만 받아 사용자에게 출력만 한다. 물론 데이터로 무엇을 할 것인지는 너어게 달려있다. 아마도 데이터를 사용자에게 출력하거나, 데이터베이스에 저장, 이메일에 전송 또는 다른 방법으로 처리할 것이다.</p>

<pre class="brush: php notranslate">&lt;?php
  // The global $_POST variable allow to access the data send with the POST method
  // To access the data send with the GET method, you can use $_GET
  $say = htmlspecialchars($_POST[&apos;say&apos;]);
  $to  = htmlspecialchars($_POST[&apos;to&apos;]);

  echo  $say, &apos; &apos;, $to;</pre>

<p>이 예제는 우리가 보낸 데이터를 페이지에 출력 할 것이다. 이 예제는 다음과 같이 출력할 것이다.</p>

<pre class="notranslate">Hi Mom</pre>

<h4 id="예제_Python">예제: Python</h4>

<p>이 예제는 파이썬을 사용하여 제공된 데이터를 웹페이지에 출력하는 예제입니다. <span style="line-height: 1.5;">CGI 파이썬 패키지를 이용하여 폼데이터에 접근한다.</span></p>

<pre class="brush: python notranslate">#!/usr/bin/env python
import html
import cgi
import cgitb; cgitb.enable()     # for troubleshooting

print(&quot;Content-Type: text/html&quot;) # HTTP header to say HTML is following
print()                          # blank line, end of headers

form = cgi.FieldStorage()
say  = html.escape(form[&quot;say&quot;].value);
to   = html.escape(form[&quot;to&quot;].value);

print(say, &quot; &quot;, to)</pre>

<p>이 결과는 PHP와 똑같다?.</p>

<pre class="notranslate">Hi Mom</pre>

<h4 id="다른_언어와_프레임_워크">다른 언어와 프레임 워크</h4>

<p> <a href="/en-US/docs/" title="/en-US/docs/">Perl</a>, <a href="/en-US/docs/" title="/en-US/docs/">Java</a>, <a href="http://www.microsoft.com/net" title="http://www.microsoft.com/net">.Net</a>, <a href="/en-US/docs/" title="/en-US/docs/">Ruby</a>등 이와 같은 다른 서버측 기술이 있다. 이중에 최고라고 생각되는 것을 사용하면된다. 즉, 까다로운 일이 될 수 있기 때문에, 직접 기술을 사용하는 것은 매우 드문 일이 있음을 언급하는 것은 가치가있다.(?) <span style="line-height: 1.5;">다음과 같은 폼을 더 쉽게 다루기위해 다음과 같은 좋은 프레임 워크들이 사용된다.</span></p>

<ul>
 <li><a href="http://symfony.com/" rel="external">Symfony</a> for PHP</li>
 <li><a href="https://www.djangoproject.com/" rel="external">Django</a> for Python</li>
 <li><a href="http://rubyonrails.org/" rel="external">Ruby On Rails</a> for Ruby</li>
 <li><a href="http://grails.org/" rel="external">Grails</a> for Java</li>
 <li>etc.</li>
</ul>

<p><span style="line-height: 1.5;">이러한 프레임 워크를 사용하는 경우에도 폼을 다루는 것은 어쩔수 없이 쉽지 않다는 것을 주목을 할 필요가 있다.</span> 그러나 이것을 사용하면 많은 시간을 절약 할 수 있다.</p>

<h2 id="특별한_경우_파일_보내기">특별한 경우: 파일 보내기</h2>

<p>파일은 HTML 폼에서 특별한 경우이다. 파일은 2진 데이터 또는 다른 데이터는 텍스트 데이터로 간주된다.HTTP는 텍스트 프로토콜 이기 때문에 2진 데이터를 다루기 위해서는 특별한 요구 사항이있다.</p>

<h3 id="enctype_속성"><code><a href="/ko/docs/Web/HTML/Element/form#attr-enctype">enctype</a></code> 속성</h3>

<p><span style="line-height: 1.5;">이 속성은 Content-Type  HTTP 헤더의 값을 지정할 수 있게 해준다. </span>서버에 데이터가 무슨 종류인지 전달하기 떄문에 이 해더는 매우 중요하다. <span style="line-height: 1.5;">기본 값으로는 application/x-www-form-urlencoded. 이다. 사람 말로는 &quot;이 폼 데이터는 URL 폼 형태로 인코딩되어 있습니다&quot; 이다</span></p>

<p>만약 파일을 보내고 싶다면 두 가지를 해야한다.</p>

<ul>
 <li><code><a href="/ko/docs/Web/HTML/Element/form#attr-method">method</a></code> 속성을 POST 속성으로 지정 해야한다. 왜냐하면 파일 콘텐츠는 폼을 이용하여 URL 매개변수로 보낼수 없기 때문이다.</li>
 <li><code><a href="/ko/docs/Web/HTML/Element/form#attr-enctype">enctype</a></code>의 값을 multipart/form-data 이라고 지정 해야한다. 왜냐하면 데이터는 여러 조각으로 나누워 지고 각 파일 조각에 같이 보내질 폼바디 텍스트가 추가 되기 때문이다.</li>
</ul>

<p>예제 </p>

<pre class="brush: html notranslate">&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
  &lt;input type=&quot;file&quot; name=&quot;myFile&quot;&gt;
  &lt;button&gt;Send the file&lt;/button&gt;
&lt;/form&gt;</pre>

<div class="note notecard">
<p><strong>Note:</strong> 몇 브라우저는 <code><a href="/ko/docs/Web/HTML/Element/input#attr-multiple">multiple</a></code>속성을 <a href="/ko/docs/Web/HTML/Element/input" title="HTML &lt;input&gt; 요소는 웹 기반 양식에서 사용자의 데이터를 받을 수 있는 대화형 컨트롤을 생성합니다."><code>&lt;input&gt;</code></a>요소에 지원하여 한번에 여러 요소를 전달 할 수 있다. 이러한 파일을 서버측에서 다루는 방법은 서버에서 어떠한 기술을 사용하냐에 따라서 매우 달라진다. 앞에서 언급 한바와 같이 프레임워크를 사용하면 더 쉽게 이용할 수있다.</p>
</div>

<div class="warning notecard">
<p><strong>Warning:</strong> 많은 서버들이 남용을 예방하기 위해 HTTP요청과 파일의 크기를 제한하도록 구성된다. 파일을 전송하기 전에 서버 관리자에게 제한 크기를 확인하는것이 중요하다.</p>
</div>

<h2 id="보안_코너">보안 코너</h2>

<p>데이터를 서버로 보낼 떄마다 보안성에 대하여 생각해 봐야한다. HTML폼은 서버를 공격하는데 첫번째 매개변수가 될 수있다. 문제는 HTML폼에서 오지 않는다. 서버에서 어떻게 처리하냐에 따라 문제가 발생한다.</p>

<h3 id="일반적인_보안_결함">일반적인 보안 결함</h3>

<p>무엇을 하는지에 따라 잘 알려진 보안 문제가 있다.</p>

<h4 id="XSS_과_CSRF">XSS 과 CSRF</h4>

<p>크로스 사이트 스크립팅(XSS)과 크로스 사이트 요청 위조(CSRF)은 데이터를 출력하기 위해 사용자나 다른 사용자에게 데이터를 보낼떄 공격하는 일반적인 유형이다.</p>

<p>XSS 공격자는 다른 사용자가 볼 웹 페이지에 클라이언트 측 스크립트를 주입할 수있다.크로스 사이트 스크립팅 취약점은 공격자가 동일 출처 정책(<a href="/en-US/docs/JavaScript/Same_origin_policy_for_JavaScript" style="line-height: 1.5;" title="/en-US/docs/JavaScript/Same_origin_policy_for_JavaScript">same origin policy</a><span style="line-height: 1.5;">)의 접근 제어를 우회하여 사용 될 수 있다.</span><span style="line-height: 1.5;"> </span><span style="line-height: 1.5;">이러한 공격은 조금 불편함에서 심각한 보안 위험에 이르기 까지 다양하게 영향을 미친다.</span></p>

<p>CSRF는 XSS와 비슷하게 공격자가 같은 방법으로 시작한다. —클라이언트 스크립트를 웹페이지에 주입한다. - 그러나 이것의 대상은 다르다. CSRF 공격자는 높은 권한 계정(서버 관리자 같은)으로 권한을 상승하려고 시도하고 하지 말아야할 행동들을 할것이다.(예를들어 신뢰 할 수없는 사용자에게 데이터 전송하는 것)</p>

<p>XSS 공격자는 사용자가 웹사이트에 대하여 가진 신뢰를 이용하여 공격자는 웹사이트가 사용자를 신뢰한다는 것을 이용한다.</p>

<p>이러한 공격을 방지하려면 사용자가 서버에 보내는 데이터를 항상 확인해야하며 해당 내용을 표시해야 하는 경우 사용자가 제공한 HTML 콘텐츠를 표시하지 말아야 한다. 대신, 당신이 보여주려는 데이터가 사용자가 제공한 것과 동일한 데이터가 아니도록 데이터를 처리해야 한다. 현재 시장에 나와있는 거의 모든 프레임 워크는 어떤 유저가 보내는 데이터라도 HTML<a href="/ko/docs/Web/HTML/Element/script" title="HTML &lt;script&gt; 요소는 실행 가능한 코드를 문서에 포함하거나 참조할 때 사용합니다. 보통 JavaScript 코드와 함께 쓰지만, WebGL의 GLSL 셰이더 프로그래밍 언어 등 다른 언어와도 사용할 수 있습니다."><code>&lt;script&gt;</code></a>,<a href="/ko/docs/Web/HTML/Element/iframe" title="HTML &lt;iframe&gt; 요소는 중첩 브라우징 맥락을 나타내는 요소로, 현재 문서 안에 다른 HTML 페이지를 삽입합니다."><code>&lt;iframe&gt;</code></a> 및 <a href="/ko/docs/Web/HTML/Element/object" title="HTML &lt;object&gt; 요소는 이미지나, 중첩된 브라우저 컨텍스트, 플러그인에 의해 다뤄질수 있는 리소스와 같은 외부 리소스를 나타냅니다."><code>&lt;object&gt;</code></a> 요소를 데이터에서 제거하는 최소한의 필터를 구현한다. 이는 위험을 완화하는 데 도움은 되지만 반드시 근절한다고 보장할 수는 없다.</p>

<h4 id="SQL_injection">SQL injection</h4>

<p>SQL injection is a type of attack that tries to perform actions on a database used by the target web site. This typically involves sending an SQL request and hopes that the server will execute it (many times when the application server tries to store the data). This is actually <a href="https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project" rel="external" title="https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project">one of the main vector attacks against web sites</a>.</p>

<p>The consequences can be terrible, ranging from data loss to access to a whole infrastructure by using privilege escalation. This is a very serious threat and you should never store data sent by a user without performing some sanitization (for example, by using <code><a href="http://www.php.net/manual/en/function.mysql-real-escape-string.php" rel="external" title="http://www.php.net/manual/en/function.mysql-real-escape-string.php">mysql_real_escape_string()</a></code> on a PHP/MySQL infrastructure).</p>

<h4 id="HTTP_header_injection_와_email_injection">HTTP header injection 와 email injection</h4>

<p>These kinds of attacks can occur when your application builds HTTP headers or emails based on the data input by a user on a form. These won&apos;t directly damage your server or affect your users but are an open door to deeper problems such as session hijacking or phishing attacks.</p>

<p>These attacks are mostly silent, and can turn your server into a <a href="http://en.wikipedia.org/wiki/Zombie_(computer_science)" rel="exernal" title="http://en.wikipedia.org/wiki/Zombie_(computer_science)">zombie</a>.</p>

<h3 id="Be_paranoid_Never_trust_your_users">Be paranoid: Never trust your users</h3>

<p>So, how do you fight these threats? This is a topic far beyond this guide; however there are a few rules it&apos;s good to keep in mind. The most important rule is: never ever trust your users, including yourself; even a trusted user could have been hijacked.</p>

<p>All data that comes to your server must be checked and sanitized. Always. No exception.</p>

<ul>
 <li>Escape potentially dangerous characters. The specific characters you should be cautious with vary depending on the context in which the data is used and the server platform you employ, but all server-side languages have functions for this.</li>
 <li>Limit the incoming amount of data to allow only what&apos;s necessary.</li>
 <li>Sandbox uploaded files (store them on a different server and allow access to the file only through a different subdomain or even better through a fully different domain name).</li>
</ul>

<p>If you follow these three rules of thumb, you should avoid many/most problems; however, it&apos;s always a good idea to get a security review performed by a competent third party. Don&apos;t assume that you&apos;ve seen all the possible problems.</p>

<h2 id="결론">결론</h2>

<p>여기서 볼 수 있듯이 폼데이터는 쉽게 보낼수 있지만 어플리케이션에서 데이터를 확보하는것은 까다로운 일이 될 수 있다. 프론트 앤드 개발자가 기억해야 할 것은 데이터 모델만 보안을 정한다고 끝이 아니라는 것이다. Yes, as we&apos;ll see, it&apos;s possible to <a href="/en-US/docs/HTML/Forms/Data_form_validation" title="/en-US/docs/HTML/Forms/Data_form_validation">perform client side data validation</a> but the server can&apos;t trust this validation because it has no way to truly know what really happens on the client side.</p>

<h2 id="볼거리">볼거리</h2>

<p>If you want to learn more about securing a web application, you can dig into these resources:</p>

<ul>
 <li><a href="https://www.owasp.org/index.php/Main_Page" rel="external">The Open Web Application Security Project (OWASP)</a></li>
 <li><a href="http://shiflett.org/" rel="external">Chris Shiflett&apos;s blog about PHP Security</a></li>
 <li><a href="https://code.google.com/intl/en/edu/security/index.html" rel="external">Learning material from Google</a></li>
</ul>
