---
title: JavaScript C Engine Embedder's Guide
slug: orphaned/JavaScript_C_Engine_Embedder's_Guide
tags:
  - SpiderMonkey
original_slug: JavaScript_C_Engine_Embedder's_Guide
---
<p>이 문서는 C로 구현된 <a href="ko/JavaScript">JavaScript</a> 엔진인 <a href="ko/SpiderMonkey">SpiderMonkey</a>를 전반적으로 소개하며, 애플리케이션이 JavaScript를 인식하도록 하기 위해 어떻게 엔진을 내장하는지에 대해 설명합니다. JavaScript엔진을 여러분의 애플리케이션에 내장하는데는 두가지 큰 이유가 있을 것입니다. 먼저, 스크립트를 사용하여 애플리케이션을 자동화하는 것이 있고, JavaScript엔진과 스크립트를 사용하여 특정 플랫폼에 의존적인 애플케이션 솔루션이 되지 않도록 크로스 플랫폼을 지원하는 것입니다.</p>
<h3 id=".EC.A7.80.EC.9B.90.EB.90.98.EB.8A.94_.EC.9E.90.EB.B0.94.EC.8A.A4.ED.81.AC.EB.A6.BD.ED.8A.B8_.EB.B2.84.EC.A0.84" name=".EC.A7.80.EC.9B.90.EB.90.98.EB.8A.94_.EC.9E.90.EB.B0.94.EC.8A.A4.ED.81.AC.EB.A6.BD.ED.8A.B8_.EB.B2.84.EC.A0.84">지원되는 자바스크립트 버전</h3>
<p>모질라 JS 엔진은 JS1.8, JS 1.3을 통해 JS1.0을 지원하고 ECMAScript-262 규약을 충족합니다. 간단하게 보면, JS 엔진은 JS 문장과 함수를 포함하는 스크립트를 파싱하여 컴파일하고 실행합니다. 해당 엔진은 스크립트 실행에 필요한 JS 개체의 메모리 할당을 관리하고 더 이상 필요하지 않을 경우, 가비지 컬렉션을 통해 개체를 지웁니다.</p>
<h3 id=".EC.9E.90.EB.B0.94.EC.8A.A4.ED.81.AC.EB.A6.BD.ED.8A.B8_.EC.97.94.EC.A7.84.EC.9D.84_.EC.96.B4.EB.96.BB.EA.B2.8C_.EC.82.AC.EC.9A.A9.ED.95.98.EB.82.98.3F" name=".EC.9E.90.EB.B0.94.EC.8A.A4.ED.81.AC.EB.A6.BD.ED.8A.B8_.EC.97.94.EC.A7.84.EC.9D.84_.EC.96.B4.EB.96.BB.EA.B2.8C_.EC.82.AC.EC.9A.A9.ED.95.98.EB.82.98.3F">자바스크립트 엔진을 어떻게 사용하나?</h3>
<p>일반적으로 JS엔진은 공유 리소스로 빌드합니다. 예를 들어, 윈도와 윈도NT에서는 DLL이고 유닉스에서는 공유 라이브러리가 됩니다. 사용방법은 간단합니다. 우선 애플리케이션에 JS엔진을 링크하고 나서 JS엔진 API를 애플리케이션에 임베딩합니다. 이렇게 하면 JS엔진 API는 다음 종류에 해당하는 기능을 제공하게 됩니다.</p>
<ul>
 <li>Data Type Manipulation</li>
 <li>Run Time Control</li>
 <li>Class and Object Creation and Maintenance</li>
 <li>Function and Script Execution</li>
 <li>String Handling</li>
 <li>Error Handling</li>
 <li>Security Control</li>
 <li>Debugging Support</li>
</ul>
<p>애플리케이션이 자바스크립트 호출을 지원하려면 런타임 제어(runtime control)와 데이터 타입 조정(datatype manipulation)등과 같은 종류의 기능을 사용합니다. 예를 들어, 어떤 자바스크립트를 호출하기전에 <code><a href="http://developer.mozilla.org/en/docs/JS_NewRuntime" class="external">JS_NewRuntime</a></code>함수를 호출해서 JS엔진을 생성하고 초기화해야 하며, 보안 제어(security control)와 같은 기능은 필요에 따라 선택적으로 사용할 수 있습니다.</p>
<h3 id="How_Does_the_Engine_Relate_to_Applications.3F" name="How_Does_the_Engine_Relate_to_Applications.3F">How Does the Engine Relate to Applications?</h3>
<p>개념적으로 JS엔진은 시스템에 존재하는 공유 리소스라고 볼 수 있습니다. API call을 애플리케이션에 임베딩하여, JS엔진에 요청을 넘길 수 있습니다. 요청을 처리한 엔진은 값이나 상태정보를 애플리케이션에 되돌려줍니다. 그림1.1은 이러한 일반적인 관계를 보여주고 있습니다.</p>
<p><b><small>그림 1.1</small></b></p>
<p><img alt="Image:Over1.gif"></p>
<p>예를 들어 여러분이 자바스크립트를 사용하여 애플리케이션을 자동화하기 위해 JS엔진을 사용한다고 가정합시다. 그리고 해당 애플리케이션에서 실행하는 스크립트에 사용자를 인증하고 애플리케이션에 사용자 접근 권한을 설정한다고 합시다. 우선, 애플리케이션은 사용자에게 이름, 아이디, 접근권한을 위한 입력과 사용자에게 허락되어 애플리케이션에서 사용 가능한 기능 리스트를 보여줄 수 있는 JS 오브젝트를 생성할 수도 있습니다.</p>
<p>이러한 경우, 애플리케이션이 처음으로 JS엔진에 요청하는 것은 <code><a href="ko/JS_NewObject">JS_NewObject</a></code>를 호출하여 사용자 정의 개체를 생성하는 것입니다. JS엔진이 개체를 생성할 때, 애플리케이션에 해당 포인터를 반환합니다. 이때 부터 애플리케이션은 해당 개체를 사용하여 스크립트를 실행하기 위해 다시 JS엔진을 호출할 수 있습니다. 예를 들어, 사용자 개체를 생성한 이후, 애플리케이션은 스크립트를 즉시 컴파일하고 실행하기 위해 바로 <code><a href="ko/JS_EvaluateScript">JS_EvaluateScript</a></code>에 전달할 것입니다. 그 결과, 좀 전의 스크립트는 사용자 정보를 얻어 확인해주고 애플리케이션이 가진 다른 기능을 사용할 수 있도록 접근 권한을 허락하게 됩니다.</p>
<p>In truth, the actual relationship between your application and the JS engine is somewhat more complex than shown in Figure 1.1. For example, it assumes that you have already built the JS engine for your platform. It assumes that your application code includes <code>jsapi.h</code>, and it assumes that the first call your application makes to the engine initializes the JS run time.</p>
<p>When the JS engine receives an initialization request, it allocates memory for the JS run time. Figure 1.2 illustrates this process:</p>
<p><b><small>Figure 1.2</small></b></p>
<p><img alt="Image:Over2.gif"></p>
<p>The run time is the space in which the variables, objects, and contexts used by your application are maintained. A context is the script execution state for a thread used by the JS engine. Each simultaneously existent script or thread must have its own context. A single JS run time may contain many contexts, objects, and variables.</p>
<p>Almost all JS engine calls require a context argument, so one of the first things your application must do after creating the run time is call <code><a href="ko/JS_NewContext">JS_NewContext</a></code> at least once to create a context. The actual number of contexts you need depends on the number of scripts you expect to use at the same time in your application. You need one context for each simultaneously existing script in your application. On the other hand, if only one script at a time is compiled and executed by your application, then you need only create a single context that you can then reuse for each script.</p>
<p>After you create contexts, you will usually want to initialize the built-in JS objects in the engine by calling <code><a href="ko/JS_InitStandardClasses">JS_InitStandardClasses</a></code>. The built-in objects include the <code>Array</code>, <code>Boolean</code>, <code>Date</code>, <code>Math</code>, <code>Number</code>, and <code>String</code> objects used in most scripts.</p>
<p>Most applications will also use custom JS objects. These objects are specific to the needs of your applications. They usually represent data structures and methods used to automate parts of your application. To create a custom object, you populate a JS class for the object, call <code><a href="ko/JS_InitClass">JS_InitClass</a></code> to set up the class in the run time, and then call <code><a href="ko/JS_NewObject">JS_NewObject</a></code> to create an instance of your custom object in the engine. Finally, if your object has properties, you may need to set the default values for them by calling <code><a href="ko/JS_SetProperty">JS_SetProperty</a></code> for each property.</p>
<p>Even though you pass a specific context to the JS engine when you create an object, an object then exists in the run time independent of the context. Any script can be associated with any context to access any object. Figure 1.3 illustrates the relationship of scripts to the run time, contexts, and objects.</p>
<p><b><small>Figure 1.3</small></b></p>
<p><img alt="Image:Over3.gif"></p>
<p>As Figure 1.3 also illustrates, scripts and contexts exist completely independent from one another even though they can access the same objects. Within a given run time, an application can always use any unassigned context to access any object. There may be times when you want to ensure that certain contexts and objects are reserved for exclusive use. In these cases, create separate run times for your application: one for shared contexts and objects, and one (or more, depending on your application's needs) for private contexts and objects.</p>
<p><b>NOTE</b>: Only one thread at a time should be given access to a specific context.</p>
<h3 id="Building_the_Engine" name="Building_the_Engine">Building the Engine</h3>
<p>Before you can use JS in your applications, you must build the JS engine as a shareable library. In most cases, the engine code ships with make files to automate the build process.</p>
<p>For example, under Unix, the js source directory contains a base gnu make file called <code>Makefile.ref</code>, and a <code>config</code> directory. The <code>config</code> directory contains platform-specific <code>.mk</code> files to use with <code>Makefile.ref</code> for your environment. Under Windows NT the nmake file is <code>js.mak</code>.</p>
<p>Always check the source directory for any <code>readme</code> files that may contain late-breaking or updated compilation instructions or information.</p>
<h3 id="What_Are_the_Requirements_for_Engine_Embedding.3F" name="What_Are_the_Requirements_for_Engine_Embedding.3F">What Are the Requirements for Engine Embedding?</h3>
<p>To make your application JS-aware, embed the appropriate engine calls in your application code. There are at least five steps to embedding:</p>
<ol>
 <li>Add <code>#include "jsapi.h"</code> to your C modules to ensure that the compiler knows about possible engine calls. Specialized JS engine work may rarely require you to include additional header files from the JS source code. For example, to include JS debugger calls in your application, code you will need to include <code>jsdbgapi.h</code> in the appropriate modules. Most other header files in the JS source code should
  <i>
   not</i>
  be included. To do so might introduce dependencies based on internal engine implementations that might change from release to release.</li>
 <li>Provide support structures and variable declarations in your application. For example, if you plan on passing a script to the JS engine, provide a string variable to hold the text version of the script in your application.Declare structures and variables using the JS data types defined in <code>jsapi.h</code>.</li>
 <li>Script application-specific objects using JavaScript. Often these objects will correspond to structures and methods that operate on those structures in your C programs, particularly if you are using the JS engine to automate your application.</li>
 <li>Embed the appropriate JS engine API calls and variable references in your application code, including calls to initialize the built-in JS objects, and to create and populate any custom objects your application uses.</li>
 <li>Most JS engine calls return a value. If this value is zero or <code>NULL</code>, it usually indicates an error condition. If the value is nonzero, it usually indicates success; in these cases, the return value is often a pointer that your application needs to use or store for future reference. At the very least, your applications should always check the return values from JS engine calls.</li>
</ol>
<p>The following code fragment illustrates most of these embedding steps, except for the creation of JS scripts, which lies outside the scope of the introductory text. For more information about creating scripts and objects using the JavaScript language itself, see the
 <i>
  Client-Side JavaScript Guide</i>
 . For further information about scripting server-side objects, see the
 <i>
  Server-Side JavaScript Guide</i>
 .</p>
<pre>.
.
.
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

/* include the JS engine API header */
#include "jsapi.h"
.
.
.

/* main function sets up global JS variables, including run time,
 * a context, and a global object, then initializes the JS run time,
 * and creates a context. */

int main(int argc, char **argv)
{
  int c, i;
  /*set up global JS variables, including global and custom objects */

  JSVersion version;
  JSRuntime *rt;
  JSContext *cx;
  JSObject  *glob, *it;
  JSBool builtins;

  /* initialize the JS run time, and return result in rt */
  rt = JS_NewRuntime(8L * 1024L * 1024L);

  /* if rt does not have a value, end the program here */
  if (!rt)
    return 1;

  /* create a context and associate it with the JS run time */
  cx = JS_NewContext(rt, 8192);

  /* if cx does not have a value, end the program here */
  if (cx == NULL)
    return 1;

  /* create the global object here */
  glob = JS_NewObject(cx, clasp, NULL, NULL);

  /* initialize the built-in JS objects and the global object */
  builtins = JS_InitStandardClasses(cx, glob);

  .
  .
  .

  return 0;

}
</pre>
<p>This example code is simplified to illustrate the key elements necessary to embed JS engine calls in your applications. For a more complete example -- from which these snippets were adapted -- see <code>js.c</code>, the sample application source code that is included with the JS engine source code.</p>
<h3 id="Understanding_Key_Embedding_Concepts" name="Understanding_Key_Embedding_Concepts">Understanding Key Embedding Concepts</h3>
<p>For most of the JavaScript aware applications you create, you will want to follow some standard JS API embedding practices. The following sections describe the types of API calls you need to embed in all your applications.</p>
<p>In many cases, the order in which you embed certain API calls is important to successful embedding. For example, you must initialize a JS run time before you can make other JS calls. Similarly, you should free the JS run time before you close your application. Therefore, your application's <b>main</b> function typically sandwiches API calls for initializing and freeing the JS run time around whatever other functionality you provide:</p>
<pre>int main(int argc, char **argv)
{
  int c, i;

  /*set up global JS variables, including global and custom objects */
  JSVersion version;
  JSRuntime *rt;
  JSContext *cx;
  JSObject  *glob, *it;

  .
  .
  .

  /* initialize the JS run time, and return result in rt */
  rt = JS_NewRuntime(8L * 1024L * 1024L);

  /* if rt does not have a value, end the program here */
  if (!rt)
    return 1;

  .
  .
  .

  /* establish a context */
  cx = JS_NewContext(rt, 8192);

  /* if cx does not have a value, end the program here */
  if (cx == NULL)
    return 1;

  /* initialize the built-in JS objects and the global object */
  builtins = JS_InitStandardClasses(cx, glob);

  .
  .
  .

  /* include your application code here, including JS API calls
   * that may include creating your own custom JS objects. The JS
   * object model starts here. */

  .
  .
  .

  /* Before exiting the application, free the JS run time */
  JS_DestroyRuntime(rt);
</pre>
<p>As this example illustrates, applications that embed calls to the JS engine are responsible for setting up the JS run time as one of its first acts, and they are responsible for freeing the run time before they exit. In general, the best place to ensure that the run time is initialized and freed is by embedding the necessary calls in whatever module you use as the central JS dispatcher in your application.</p>
<p>After you initialize the run time, you can establish your application's JS object model. The object model determines how your JS objects relate to one another. JS objects are hierarchical in nature. All JS objects are related to the global object by default. They are descendants of the global object. You automatically get a global object when you initialize the standard JS classes:</p>
<pre class="eval">builtins = JS_InitStandardClasses(cx, glob);
</pre>
<p>The global object sets up some basic properties and methods that are inherited by all other objects. When you create your own custom objects, they automatically use the properties and methods defined on the global object. You can override these default properties and methods by defining them again on your custom object, or you can accept the default assignments.</p>
<p>You can also create custom objects that are based on other built-in JS objects, or that are based on other custom objects. In each case, the object you create inherits all of the properties and methods of its predecessors in the hierarchical chain, all the way up to the global object. For more information about global and custom objects, see <a href="#Initializing_Built-in_and_Global_JS_Objects">Initializing Built-in and Global JS Objects</a> and <a href="#Creating_and_Initializing_Custom_Objects">Creating and Initializing Custom Objects</a>.</p>
<h3 id="Managing_a_Run_Time" name="Managing_a_Run_Time">Managing a Run Time</h3>
<p>The JS run time is the memory space the JS engine uses to manage the contexts, objects, and variables associated with JS functions and scripts. Before you can execute any JS functions or scripts you must first initialize a run time. The API call that initializes the run time is <code><a href="ko/JS_NewRuntime">JS_NewRuntime</a></code>. <code><a href="ko/JS_NewRuntime">JS_NewRuntime</a></code> takes a single argument, an unsigned integer that specifies the maximum number of bytes of memory to allocate to the run time before garbage collection occurs. For example:</p>
<pre class="eval"> rt = JS_NewRuntime(8L * 1024L * 1024L);
</pre>
<p>As this example illustrates, <code><a href="ko/JS_NewRuntime">JS_NewRuntime</a></code> also returns a single value, a pointer to the run time it creates. A non-NULL return value indicates successful creation of the run time.</p>
<p>Normally, you only need one run time for an application. It is possible, however, to create multiple run times by calling <code><a href="ko/JS_NewRuntime">JS_NewRuntime</a></code> as necessary and storing the return value in a different pointer.</p>
<p>When the JS run time is no longer needed, it should be destroyed to free its memory resources for other application uses. Depending on the scope of JS use in your application, you may choose to destroy the run time immediately after its use, or, more likely, you may choose to keep the run time available until your application is ready to terminate. In either case, use the <code><a href="ko/JS_DestroyRuntime">JS_DestroyRuntime</a></code> to free the run time when it is no longer needed. This function takes a single argument, the pointer to the run time to destroy:</p>
<pre class="eval"> JS_DestroyRuntime(rt);
</pre>
<p>If you use multiple run times, be sure to free each of them before ending your application.</p>
<h3 id="Managing_Contexts" name="Managing_Contexts">Managing Contexts</h3>
<p>Almost all JS API calls require you to pass a context as an argument. A context identifies a script in the JavaScript engine. The engine passes context information to the thread that runs the script. Each simultaneously-executing script must be assigned a unique context. When a script completes execution, its context is no longer in use, so the context can be reassigned to a new script, or it can be freed.</p>
<p>To create a new context for a script, use <code><a href="ko/JS_NewContext">JS_NewContext</a></code>. This function takes two arguments: a pointer to the run time with which to associate this context, and the number of bytes of stack space to allocate for the context. If successful, the function returns a pointer to the newly established context. For example:</p>
<pre class="eval"> JSContext *cx;
 .
 .
 .
 cx = JS_NewContext(rt, 8192);
</pre>
<p>The run time must already exist. The stack size you specify for the context should be large enough to accommodate any variables or objects created by the script that uses the context. Note that because there is a certain amount of overhead associated with allocating and maintaining contexts you will want to:</p>
<ol>
 <li>Create only as many contexts as you need at one time in your application.</li>
 <li>Keep contexts for as long as they may be needed in your application rather than destroying and recreating them as needed.</li>
</ol>
<p>When a context is no longer needed, it should be destroyed to free its memory resources for other application uses. Depending on the scope of JS use in your application, you may choose to destroy the context immediately after its use, or, more likely, you may choose to keep the context available for reuse until your application is ready to terminate. In either case, use the <code><a href="ko/JS_DestroyContext">JS_DestroyContext</a></code> to free the context when it is no longer needed. This function takes a single argument, the pointer to the context to destroy:</p>
<pre class="eval"> JS_DestroyContext(cx);
</pre>
<p>If your application creates multiple run times, the application may need to know which run time a context is associated with. In this case, call <code><a href="ko/JS_GetRuntime">JS_GetRuntime</a></code>, and pass the context as an argument. <code><a href="ko/JS_GetRuntime">JS_GetRuntime</a></code> returns a pointer to the appropriate run time if there is one:</p>
<pre class="eval"> rt = JS_GetRuntime(cx);
</pre>
<p>When you create a context, you assign it stack space for the variables and objects that get created by scripts that use the context. You can also store large amounts of data for use with a given context, yet minimize the amount of stack space you need. Call <code><a href="ko/JS_SetContextPrivate">JS_SetContextPrivate</a></code> to establish a pointer to private data for use with the context, and call <code><a href="ko/JS_GetContextPrivate">JS_GetContextPrivate</a></code> to retrieve the pointer so that you can access the data. Your application is responsible for creating and managing this optional private data.</p>
<p>To create private data and associate it with a context:</p>
<ol>
 <li>Establish the private data as you would a normal C void pointer variable.</li>
 <li>Call <code><a href="ko/JS_SetContextPrivate">JS_SetContextPrivate</a></code>, and specify the context for which to establish private data, and specify the pointer to the data.</li>
</ol>
<p>For example:</p>
<pre class="eval"> JS_SetContextPrivate(cx, pdata);
</pre>
<p>To retrieve the data at a later time, call <code><a href="ko/JS_GetContextPrivate">JS_GetContextPrivate</a></code>, and pass the context as an argument. This function returns the pointer to the private data:</p>
<pre class="eval"> pdata = JS_GetContextPrivate(cx);
</pre>
<h3 id="Initializing_Built-in_and_Global_JS_Objects" name="Initializing_Built-in_and_Global_JS_Objects">Initializing Built-in and Global JS Objects</h3>
<p>The JavaScript engine provides several built-in objects that simplify some of your development tasks. For example, the built-in <code>Array</code> object makes it easy for you to create and manipulate array structures in the JS engine. Similarly, the Date object provides a uniform mechanism for working with and handling dates. For a complete list of built-in objects supported in the engine, see the reference entry for <code><a href="ko/JS_InitStandardClasses">JS_InitStandardClasses</a></code>.</p>
<p>The JS engine always uses function and global objects. In general, the global object resides behind the scenes, providing a default scope for all other JS objects and global variables you create and use in your applications. Before you can create your own objects, you will want to initialize the global object. The function object enables objects to have and call constructors.</p>
<p>A single API call, <code><a href="ko/JS_InitStandardClasses">JS_InitStandardClasses</a></code>, initializes the global and function objects and the built-in engine objects so that your application can use them:</p>
<pre class="eval"> JSBool builtins;
 .
 .
 .
 builtins = JS_InitStandardClasses(cx, glob);
</pre>
<p><code><a href="ko/JS_InitStandardClasses">JS_InitStandardClasses</a></code> returns a JS boolean value that indicates the success or failure of the initialization.</p>
<p>You can specify a different global object for your application. For example, the Netscape Navigator uses its own global object, window. To change the global object for you application, call <code><a href="ko/JS_SetGlobalObject">JS_SetGlobalObject</a></code>. For more information, see the reference entry for <code><a href="ko/JS_SetGlobalObject">JS_SetGlobalObject</a></code>.</p>
<h3 id="Creating_and_Initializing_Custom_Objects" name="Creating_and_Initializing_Custom_Objects">Creating and Initializing Custom Objects</h3>
<p>In addition to using the engine's built-in objects, you will create, initialize, and use your own JS objects. This is especially true if you are using the JS engine with scripts to automate your application. Custom JS objects can provide direct program services, or they can serve as interfaces to your program's services. For example, a custom JS object that provides direct service might be one that handles all of an application's network access, or might serve as an intermediary broker of database services. Or a JS object that mirrors data and functions that already exist in the application may provide an object-oriented interface to C code that is not otherwise, strictly-speaking, object-oriented itself. Such a custom object acts as an interface to the application itself, passing values from the application to the user, and receiving and processing user input before returning it to the application. Such an object might also be used to provide access control to the underlying functions of the application.</p>
<p>There are two ways to create custom objects that the JS engine can use:</p>
<ul>
 <li>Write a JS script that creates an object, its properties, methods, and constructor, and then pass the script to the JS engine at run time.</li>
 <li>Embed code in your application that defines the object's properties and methods, call the engine to initialize a new object, and then set the object's properties through additional engine calls. An advantage of this method is that your application can contain native methods that directly manipulate the object embedding.</li>
</ul>
<p>In either case, if you create an object and then want it to persist in the run time where it can be used by other scripts, you must root the object by calling <code><a href="ko/JS_AddRoot">JS_AddRoot</a></code> or <code><a href="ko/JS_AddNamedRoot">JS_AddNamedRoot</a></code>. Using these functions ensures that the JS engine will keep track of the objects and clean them up during garbage collection, if appropriate.</p>
<h3 id="Creating_an_Object_From_a_Script" name="Creating_an_Object_From_a_Script">Creating an Object From a Script</h3>
<p>One reason to create a custom JS object from a script is when you only need an object to exist as long as the script that uses it is executing. To create objects that persist across script calls, you can embed the object code in your application instead of using a script.</p>
<p><b>NOTE</b>: You can also use scripts to create persistent objects, too.</p>
<p>To create a custom object using a script:</p>
<ol>
 <li>Define and spec the object. What is it intended to do? What are its data members (properties)? What are its methods (functions)? Does it require a run time constructor function?</li>
 <li>Code the JS script that defines and creates the object. For example: function myfun(){ var x = newObject(); . . . } <b>NOTE</b>: Object scripting using JavaScript occurs outside the context of embedding the JS engine in your applications. For more information about object scripting, see the
  <i>
   Client-Side JavaScript Guide</i>
  and the
  <i>
   Server-Side JavaScript Guide</i>
  . Embed the appropriate JS engine call(s) in your application to compile and execute the script. You have two choices: 1.) compile and execute a script with a single call to <code><a href="ko/JS_EvaluateScript">JS_EvaluateScript</a></code>, <code><a href="ko/JS_EvaluateUCScript">JS_EvaluateUCScript</a></code> or 2.) compile the script once with a call to <code><a href="ko/JS_CompileScript">JS_CompileScript</a></code> or <code><a href="ko/JS_CompileUCScript">JS_CompileUCScript</a></code>, and then execute it repeatedly with individual calls to <code><a href="ko/JS_ExecuteScript">JS_ExecuteScript</a></code>. The "UC" versions of these calls provide support for Unicode-encoded scripts.</li>
</ol>
<p>An object you create using a script only can be made available only during the lifetime of the script, or can be created to persist after the script completes execution. Ordinarily, once script execution is complete, its objects are destroyed. In many cases, this behavior is just what your application needs. In other cases, however, you will want object persistence across scripts, or for the lifetime of your application. In these cases you need to embed object creation code directly in your application, or you need to tie the object directly to the global object so that it persists as long as the global object itself persists.</p>
<h3 id="Embedding_a_Custom_Object_in_an_Application" name="Embedding_a_Custom_Object_in_an_Application">Embedding a Custom Object in an Application</h3>
<p>Embedding a custom JS object in an application is useful when object persistence is required or when you know that you want an object to be available to several scripts. For example, a custom object that represents a user's ID and access rights may be needed during the entire lifetime of the application. It saves overhead and time to create and populate this object once, instead of recreating it over and over again with a script each time the user's ID or permissions need to be checked.</p>
<p>One way to embed a custom object in an application is to:</p>
<ol>
 <li>Create a <code><a href="ko/JSPropertySpec">JSPropertySpec</a></code> data type, and populate it with the property information for your object, including the name of the property's get and set methods.</li>
 <li>Create a <code><a href="ko/JSFunctionSpec">JSFunctionSpec</a></code> data type, and populate it with information about the methods used by your object.</li>
 <li>Create the actual C functions that are executed in response to your object's method calls.</li>
 <li>Call to <code><a href="ko/JS_NewObject">JS_NewObject</a></code> or <code><a href="ko/JS_ConstructObject">JS_ConstructObject</a></code> to instantiate the object.</li>
 <li>Call <code><a href="ko/JS_DefineFunctions">JS_DefineFunctions</a></code> to create the object's methods.</li>
 <li>Call <code><a href="ko/JS_DefineProperties">JS_DefineProperties</a></code> to create the object's properties.</li>
</ol>
<p>The code that describes persistent, custom JS objects should be placed near the start of application execution, before any code that relies upon the prior existence of the object. Embedded engine calls that instantiate and populate the custom object should also appear before any code that relies on the prior existence of the object.</p>
<p><b>NOTE</b>: An alternate, and in many cases, easier way to create a custom object in application code is to call <code><a href="ko/JS_DefineObject">JS_DefineObject</a></code> to create the object, and then make repeated calls to <code><a href="ko/JS_SetProperty">JS_SetProperty</a></code> to set the object's properties. For more information about defining an object, see <code><a href="ko/JS_DefineObject">JS_DefineObject</a></code> . For more information about setting an object's properties, see <code><a href="ko/JS_SetProperty">JS_SetProperty</a></code>.</p>
<h3 id="Providing_Private_Data_for_Objects" name="Providing_Private_Data_for_Objects">Providing Private Data for Objects</h3>
<p>Like contexts, you can associate large quantities of data with an object without having to store the data in the object itself. Call <code><a href="ko/JS_SetPrivate">JS_SetPrivate</a></code> to establish a pointer to private data for the object, and call <code><a href="ko/JS_GetPrivate">JS_GetPrivate</a></code> to retrieve the pointer so that you can access the data. Your application is responsible for creating and managing this optional private data.</p>
<p>To create private data and associate it with an object:</p>
<ol>
 <li>Establish the private data as you would a normal C void pointer variable.</li>
 <li>Call <code><a href="ko/JS_SetPrivate">JS_SetPrivate</a></code>, specify the object for which to establish private data, and specify the pointer to the data.</li>
</ol>
<p>For example:</p>
<pre class="eval"> JS_SetPrivate(cx, obj, pdata);
</pre>
<p>To retrieve the data at a later time, call <code><a href="ko/JS_GetPrivate">JS_GetPrivate</a></code>, and pass the object as an argument. This function returns the pointer to an object's private data:</p>
<pre class="eval"> pdata = JS_GetPrivate(cx, obj);
</pre>
<h3 id="Handling_Unicode" name="Handling_Unicode">Handling Unicode</h3>
<p>The JS engine now provides Unicode-enabled versions of many API functions that handle scripts, including JS functions. These functions permit you to pass Unicode-encoded scripts directly to the engine for compilation and execution. The following table lists standard engine functions and their Unicode equivalents:</p>
<table class="fullwidth-table">
 <tbody>
  <tr>
   <th>Standard Function</th>
   <th>Unicode-enabled Function</th>
  </tr>
  <tr>
   <td><a href="ko/JS_DefineProperty">JS_DefineProperty</a></td>
   <td><a href="ko/JS_DefineUCProperty">JS_DefineUCProperty</a></td>
  </tr>
  <tr>
   <td><a href="ko/JS_DefinePropertyWithTinyId">JS_DefinePropertyWithTinyId</a></td>
   <td><a href="ko/JS_DefineUCPropertyWithTinyId">JS_DefineUCPropertyWithTinyId</a></td>
  </tr>
  <tr>
   <td><a href="ko/JS_LookupProperty">JS_LookupProperty</a></td>
   <td><a href="ko/JS_LookupUCProperty">JS_LookupUCProperty</a></td>
  </tr>
  <tr>
   <td><a href="ko/JS_GetProperty">JS_GetProperty</a></td>
   <td><a href="ko/JS_GetUCProperty">JS_GetUCProperty</a></td>
  </tr>
  <tr>
   <td><a href="ko/JS_SetProperty">JS_SetProperty</a></td>
   <td><a href="ko/JS_SetUCProperty">JS_SetUCProperty</a></td>
  </tr>
  <tr>
   <td><a href="ko/JS_DeleteProperty2">JS_DeleteProperty2</a></td>
   <td><a href="ko/JS_DeleteUCProperty2">JS_DeleteUCProperty2</a></td>
  </tr>
  <tr>
   <td><a href="ko/JS_CompileScript">JS_CompileScript</a></td>
   <td><a href="ko/JS_CompileUCScript">JS_CompileUCScript</a></td>
  </tr>
  <tr>
   <td><a href="ko/JS_CompileScriptForPrincipals">JS_CompileScriptForPrincipals</a></td>
   <td><a href="ko/JS_CompileUCScriptForPrincipals">JS_CompileUCScriptForPrincipals</a></td>
  </tr>
  <tr>
   <td><a href="ko/JS_CompileFunction">JS_CompileFunction</a></td>
   <td><a href="ko/JS_CompileUCFunction">JS_CompileUCFunction</a></td>
  </tr>
  <tr>
   <td><a href="ko/JS_CompileFunctionForPrincipals">JS_CompileFunctionForPrincipals</a></td>
   <td><a href="ko/JS_CompileUCFunctionForPrincipals">JS_CompileUCFunctionForPrincipals</a></td>
  </tr>
  <tr>
   <td><a href="ko/JS_EvaluateScript">JS_EvaluateScript</a></td>
   <td><a href="ko/JS_EvaluateUCScript">JS_EvaluateUCScript</a></td>
  </tr>
  <tr>
   <td><a href="ko/JS_EvaluateScriptForPrincipals">JS_EvaluateScriptForPrincipals</a></td>
   <td><a href="ko/JS_EvaluateUCScriptForPrincipals">JS_EvaluateUCScriptForPrincipals</a></td>
  </tr>
  <tr>
   <td><a href="ko/JS_NewString">JS_NewString</a></td>
   <td><a href="ko/JS_NewUCString">JS_NewUCString</a></td>
  </tr>
  <tr>
   <td><a href="ko/JS_NewStringCopyN">JS_NewStringCopyN</a></td>
   <td><a href="ko/JS_NewUCStringCopyN">JS_NewUCStringCopyN</a></td>
  </tr>
  <tr>
   <td><a href="ko/JS_NewStringCopyZ">JS_NewStringCopyZ</a></td>
   <td><a href="ko/JS_NewUCStringCopyZ">JS_NewUCStringCopyZ</a></td>
  </tr>
  <tr>
   <td><a href="ko/JS_InternString">JS_InternString</a></td>
   <td><a href="ko/JS_InternUCString">JS_InternUCString</a></td>
  </tr>
  <tr>
   <td>--</td>
   <td><a href="ko/JS_InternUCStringN">JS_InternUCStringN</a></td>
  </tr>
 </tbody>
</table>
<p>Unicode-enabled functions work exactly like their traditional namesakes, except that where traditional functions take a <code>char *</code> argument, the Unicode versions take a <code>jschar *</code> argument.</p>
<h3 id="Working_with_JS_Data_Types" name="Working_with_JS_Data_Types">Working with JS Data Types</h3>
<p>JavaScript defines its own data types. Some of these data types correspond directly to their C counterparts. Others, such as <code><a href="ko/JSObject">JSObject</a></code>, <code><a href="ko/Jsdouble">jsdouble</a></code>, and <code><a href="ko/JSString">JSString</a></code>, are specific to JavaScript.</p>
<p>Generally, you declare and use JS data types in your application just as you do standard C data types. The JS engine, however, keeps separate track of JS data type variables that require more than a word of storage: <code><a href="ko/JSObject">JSObject</a></code>, <code><a href="ko/Jsdouble">jsdouble</a></code>, and <code><a href="ko/JSString">JSString</a></code>. Periodically, the engine examines these variables to see if they are still in use, and if they are not, it garbage collects them, freeing the storage space for reuse.</p>
<p>Garbage collection makes effective reuse of the heap, but overly frequent garbage collection may be a performance issue. You can control the approximate frequency of garbage collection based on the size of the JS run time you allocate for your application in relation to the number of JS variables and objects your application uses. If your application creates and uses many JS objects and variables, you may want to allocate a sufficiently large run time to reduce the likelihood of frequent garbage collection.</p>
<p><b>NOTE</b>: Your application can also call <code><a href="ko/JS_GC">JS_GC</a></code> or <code><a href="ko/JS_MaybeGC">JS_MaybeGC</a></code> to force garbage collection at any time. <code><a href="ko/JS_GC">JS_GC</a></code> forces garbage collection. <code><a href="ko/JS_MaybeGC">JS_MaybeGC</a></code> performs conditional garbage collection only if a certain percentage of space initially allocated to the run time is in use at the time you invoke the function.</p>
<h3 id="Working_with_JS_Values" name="Working_with_JS_Values">Working with JS Values</h3>
<p>In addition to JS data types, the JS engine also uses JS values, called <code><a href="ko/Jsval">jsval</a></code>s. A <code><a href="ko/Jsval">jsval</a></code> is essentially a pointer to any JS data type except integers. For integers, a <code><a href="ko/Jsval">jsval</a></code> contains the integer value itself. In other cases, the pointer is encoded to contain additional information about the type of data to which it points. Using <code><a href="ko/Jsval">jsval</a></code>s improves engine efficiency, and permits many API functions to handle a variety of underlying data types.</p>
<p>The engine API contains a group of macros that test the JS data type of a <code><a href="ko/Jsval">jsval</a></code>. These are:</p>
<ul>
 <li><code><a href="ko/JSVAL_IS_OBJECT">JSVAL_IS_OBJECT</a></code></li>
 <li><code><a href="ko/JSVAL_IS_NUMBER">JSVAL_IS_NUMBER</a></code></li>
 <li><code><a href="ko/JSVAL_IS_INT">JSVAL_IS_INT</a></code></li>
 <li><code><a href="ko/JSVAL_IS_DOUBLE">JSVAL_IS_DOUBLE</a></code></li>
 <li><code><a href="ko/JSVAL_IS_STRING">JSVAL_IS_STRING</a></code></li>
 <li><code><a href="ko/JSVAL_IS_BOOLEAN">JSVAL_IS_BOOLEAN</a></code></li>
</ul>
<p>Besides testing a <code><a href="ko/Jsval">jsval</a></code> for its underlying data type, you can test it to determine if it is a primitive JS data type (<code><a href="ko/JSVAL_IS_PRIMITIVE">JSVAL_IS_PRIMITIVE</a></code>). Primitives are values that are undefined, null, boolean, numeric, or string types.</p>
<p>You can also test the value pointed to by a <code><a href="ko/Jsval">jsval</a></code> to see if it is <code>NULL</code> (<code><a href="ko/JSVAL_IS_NULL">JSVAL_IS_NULL</a></code>) or void (<code><a href="ko/JSVAL_IS_VOID">JSVAL_IS_VOID</a></code>).</p>
<p>If a jsval points to a JS data type of <code><a href="ko/JSObject">JSObject</a></code>, <code><a href="ko/Jsdouble">jsdouble</a></code>, or <code><a href="ko/Jsstr">jsstr</a></code>, you can cast the <code><a href="ko/Jsval">jsval</a></code> to its underlying data type using <code><a href="ko/JSVAL_TO_OBJECT">JSVAL_TO_OBJECT</a></code>, <code><a href="ko/JSVAL_TO_DOUBLE">JSVAL_TO_DOUBLE</a></code>, and <code><a href="ko/JSVAL_TO_STRING">JSVAL_TO_STRING</a></code>, respectively. This is useful in some cases where your application or a JS engine call requires a variable or argument of a specific data type, rather than a <code><a href="ko/Jsval">jsval</a></code>. Similarly, you can convert a <code><a href="ko/JSObject">JSObject</a></code>, <code><a href="ko/Jsdouble">jsdouble</a></code>, and <code><a href="ko/Jsstr">jsstr</a></code> to a <code><a href="ko/Jsval">jsval</a></code> using <code><a href="ko/OBJECT_TO_JSVAL">OBJECT_TO_JSVAL</a></code>, <code><a href="ko/DOUBLE_TO_JSVAL">DOUBLE_TO_JSVAL</a></code>, and <code><a href="ko/STRING_TO_JSVAL">STRING_TO_JSVAL</a></code>, respectively.</p>
<h3 id="Unicode_String_Support" name="Unicode_String_Support">Unicode String Support</h3>
<p>As with other API calls, the names of Unicode-enabled API string functions correspond one-for-one with the standard engine API string function names as follows: if a standard function name is <code><a href="ko/JS_NewStringCopyN">JS_NewStringCopyN</a></code>, the corresponding Unicode version of the function is <code><a href="ko/JS_NewUCStringCopyN">JS_NewUCStringCopyN</a></code>. Unicode-enabled API string functions are also available for interned string.</p>
<h3 id="Interned_String_Support" name="Interned_String_Support">Interned String Support</h3>
<p>To save storage space, the JS engine provides support for sharing a single instance of a string among separate invocations. Such shared strings are called "interned strings". Use interned strings when you know that a particular, string of text will be created and used more than once in an application.</p>
<p>The engine API offers several calls for working with interned strings:</p>
<ul>
 <li><code><a href="ko/JS_InternString">JS_InternString</a></code>, for creating or reusing a <code><a href="ko/JSString">JSString</a></code>.</li>
 <li><code><a href="ko/JS_InternUCString">JS_InternUCString</a></code>, for creating or reusing a Unicode <code><a href="ko/JSString">JSString</a></code>.</li>
 <li><code><a href="ko/JS_InternUCStringN">JS_InternUCStringN</a></code>, for creating or reusing Unicode <code><a href="ko/JSString">JSString</a></code> of fixed length.</li>
</ul>
<h3 id="Managing_Security" name="Managing_Security">Managing Security</h3>
<p>With JavaScript 1.3, the JS engine added security-enhanced API functions for compiling and evaluating scripts and functions passed to the engine. The JS security model is based on the Java principals security model. This model provides a common security interface, but the actual security implementation is up to you.</p>
<p>One common way that security is used in a JavaScript-enabled application is to compare script origins and perhaps limit script interactions. For example, you might compare the codebase of two or more scripts in an application and only allow scripts from the same codebase to modify properties of scripts that share codebases.</p>
<p>To implement secure JS, follow these steps:</p>
<ol>
 <li>Declare one or more structs of type <code><a href="ko/JSPrincipals">JSPrincipals</a></code> in your application code.</li>
 <li>Implement the functions that will provide security information to the array. These include functions that provide an array of principals for your application, and mechanisms for incrementing and decrementing a reference count on the number of JS objects using a given set of principles.</li>
 <li>Populate the <code><a href="ko/JSPrincipals">JSPrincipals</a></code> struct with your security information. This information can include common codebase information.</li>
 <li>At run time, compile and evaluate all scripts and functions for which you intend to apply security using the JS API calls that require you to pass in a <code><a href="ko/JSPrincipals">JSPrincipals</a></code> struct. The following table lists these API functions and their purposes:</li>
</ol>
<table class="fullwidth-table">
 <tbody>
  <tr>
   <th>Function</th>
   <th>Purpose</th>
  </tr>
  <tr>
   <td><code><a href="ko/JS_CompileScriptForPrincipals">JS_CompileScriptForPrincipals</a></code></td>
   <td>Compiles, but does not execute, a security-enabled script.</td>
  </tr>
  <tr>
   <td><code><a href="ko/JS_CompileUCScriptForPrincipals">JS_CompileUCScriptForPrincipals</a></code></td>
   <td>Compiles, but does not execute, a security-enabled, Unicode-encoded script.</td>
  </tr>
  <tr>
   <td><code><a href="ko/JS_CompileFunctionForPrincipals">JS_CompileFunctionForPrincipals</a></code></td>
   <td>Creates a security-enabled JS function from a text string.</td>
  </tr>
  <tr>
   <td><code><a href="ko/JS_CompileUCFunctionForPrincipals">JS_CompileUCFunctionForPrincipals</a></code></td>
   <td>Creates a JS function with security information from a Unicode-encoded character string.</td>
  </tr>
  <tr>
   <td><code><a href="ko/JS_EvaluateScriptForPrincipals">JS_EvaluateScriptForPrincipals</a></code></td>
   <td>Compiles and executes a security-enabled script.</td>
  </tr>
  <tr>
   <td><code><a href="ko/JS_EvaluateUCScriptForPrincipals">JS_EvaluateUCScriptForPrincipals</a></code></td>
   <td>Compiles and executes a security-enabled, Unicode-encoded character script.</td>
  </tr>
 </tbody>
</table>
<p> </p>
