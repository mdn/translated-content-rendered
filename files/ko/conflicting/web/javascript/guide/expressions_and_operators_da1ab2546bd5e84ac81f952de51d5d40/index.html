---
title: Bitwise Operators
slug: >-
  conflicting/Web/JavaScript/Guide/Expressions_and_Operators_da1ab2546bd5e84ac81f952de51d5d40
translation_of: Web/JavaScript/Guide/Expressions_and_Operators
translation_of_original: Web/JavaScript/Guide/Obsolete_Pages/Operators/Bitwise_Operators
original_slug: >-
  Web/JavaScript/Guide/Obsolete_Pages/Core_JavaScript_1.5_Guide/Operators/Bitwise_Operators
---
<p><br>
</p>
<h3 id=".EB.B9.84.ED.8A.B8_.EC.97.B0.EC.82.B0.EC.9E.90" name=".EB.B9.84.ED.8A.B8_.EC.97.B0.EC.82.B0.EC.9E.90"> 비트 연산자 </h3>
<p>비트 연산자는 피연산자를 10진수나 16진수, 8진수로 다루지 않고 32개의 비트 집합으로 다룹니다. 예를 들어, 10진수 9는 2진수로 1001입니다. 비트 연산자는 2진수 표현으로 연산을 하지만 반환값은 JavaScript 표준 수 값으로 반환합니다.
</p><p>JavaScript의 비트 연산자를 다음 표에 요약했습니다.
</p>
<table class="fullwidth-table">
<tbody><tr>
<th>연산자</th>
<th>사용법</th>
<th>설명</th>
</tr>
<tr>
<td>비트 AND</td>
<td><code>a &amp; b</code></td>
<td>두 피연산자의 대응되는 비트가 모두 1이면 1을 반환.</td>
</tr>
<tr>
<td>비트 OR</td>
<td><code>a | b</code></td>
<td>두 피연산자의 대응되는 비트에서 둘 중 하나가 1이거나 모두 1인 경우 1을 반환.</td>
</tr>
<tr>
<td>비트 XOR</td>
<td><code>a ^ b</code></td>
<td>두 피연산자의 대응되는 비트에서 둘 중 하나가 1이고, 둘 다 1이 아닐 경우 1을 반환.</td>
</tr>
<tr>
<td>비트 NOT</td>
<td><code>~ a</code></td>
<td>피연산자의 비트를 뒤집음.</td>
</tr>
<tr>
<td>왼쪽으로 이동</td>
<td><code>a &lt;&lt; b</code></td>
<td>a의 2진수 표현을 b 비트만큼 왼쪽으로 이동함. 오른쪽은 0으로 채움.</td>
</tr>
<tr>
<td>부호 비트로 채우는 오른쪽 이동</td>
<td><code>a &gt;&gt; b</code></td>
<td>a의 2진수 표현을 b 비트만큼 오른쪽으로 이동함. 오른쪽 남는 비트는 버림.</td>
</tr>
<tr>
<td>0으로 채우는 오른쪽 이동</td>
<td><code>a &gt;&gt;&gt; b</code></td>
<td>a의 2진수 표현을 b 비트만큼 오른쪽으로 이동함. 오른쪽 남는 비트는 버리고, 왼쪽은 0으로 채움.</td>
</tr>
</tbody></table>
<p><small><b>표 3.5: 비트 연산자</b></small>
</p>
<h4 id=".EB.B9.84.ED.8A.B8_.EB.85.BC.EB.A6.AC_.EC.97.B0.EC.82.B0.EC.9E.90" name=".EB.B9.84.ED.8A.B8_.EB.85.BC.EB.A6.AC_.EC.97.B0.EC.82.B0.EC.9E.90"> 비트 논리 연산자 </h4>
<p>개념적으로 비트 논리 연산자는 다음과 같이 동작합니다.
</p>
<ul><li> 피연산자는 32비트 정수로 변환되어 비트의 나열로 표현됩니다.
</li><li> 두 피연산자의 비트를 같은 위치에 있는 것 끼리 짝을 짓습니다.
</li><li> 짝 지어진 각각의 쌍에 대해서 연산자를 적용하여 결과를 만들어냅니다.
</li></ul>
<p>예를 들어, 9를 2진수로 쓰면 1001이고 15를 2진수로 표현하면 1111입니다. 두 값에 비트 연산을 적용하면 결과는 다음과 같습니다.
</p>
<ul><li> 15 &amp; 9 yields 9 (1111 &amp; 1001 = 1001)
</li><li> 15 | 9 yields 15 (1111 | 1001 = 1111)
</li><li> 15 ^ 9 yields 6 (1111 ^ 1001 = 0110)
</li></ul>
<h4 id=".EB.B9.84.ED.8A.B8_.EC.9D.B4.EB.8F.99_.EC.97.B0.EC.82.B0.EC.9E.90" name=".EB.B9.84.ED.8A.B8_.EC.9D.B4.EB.8F.99_.EC.97.B0.EC.82.B0.EC.9E.90"> 비트 이동 연산자 </h4>
<p>비트 이동 연산자는 피연산자 두 개를 받습니다. 첫 번째는 이동하려는 수이고, 두 번째는 첫 번째 피연산자를 몇 비트나 이동시킬지 나타내는 비트 수입니다. 이동 방향은 사용된 연산자에 따라 다릅니다.
</p><p>이동 연산자는 피연산자를 32비트 정수로 변환하여 연산하고, 왼쪽 연산자와 같은 자료형으로 반환합니다.
</p><p>이동 연산자는 다음 표에 있습니다.
</p>
<table class="fullwidth-table">
<tbody><tr>
<th>연산자</th>
<th>설명</th>
<th>예제</th>
</tr>
<tr>
<td>&lt;&lt;<br>
(왼쪽 이동)</td>
<td>이 연산자는 첫 번째 피연산자의 비트를 지정된 수만큼 왼쪽으로 옮깁니다. 왼쪽으로 넘친 비트는 버립니다. 오른쪽 빈 자리는 0으로 채웁니다.</td> <td>9&lt;&lt;2는 36을 반환합니다. 1001을 왼쪽으로 2비트 이동하면 100100이 되고 이것은 36이기 때문입니다.</td>
</tr>
<tr>
<td>&gt;&gt;<br>
(부호 비트로 채우는 오른쪽 이동)</td>
<td>이 연산자는 첫 번째 피연산자의 비트를 지정된 수 만큼 오른쪽으로 옮깁니다. 오른쪽으로 넘친 비트는 버립니다. 왼쪽 빈 자리는 원래 가장 왼쪽에 있던 비트 값으로 채웁니다.</td>
<td>9&gt;&gt;2는 2를 반환합니다. 1001을 2비트 오른쪽으로 이동하면 10이 되는데 이것은 2이기 때문입니다. 비슷하게 -9&gt;&gt;2는 -3을 반환하는데, 부호가 유지되기 때문입니다.</td>
</tr>
<tr>
<td>&gt;&gt;&gt;<br>
(0으로 채우는 오른쪽 이동)</td>
<td>이 연산자는 첫 번째 피연산자의 비트를 지정된 수 만큼 오른쪽으로 옮깁니다. 오른쪽으로 넘친 비트는 버립니다. 왼쪽 빈 자리는 0으로 채웁니다.</td>
<td>19&gt;&gt;&gt;2는 4를 반환합니다. 10011을 2비트 오른쪽으로 이동하면 100이 되기 때문입니다. 음수가 아닌 수에 대해서는 0을 채우는 오른쪽 이동이나 부호 비트로 채우는 오른쪽 이동이 똑같은 결과를 반환합니다.</td>
</tr>
</tbody></table>
<p><small><b>표 3.6: 비트 이동 연산자</b></small>
</p><p></p><div style="text-align: right;" class="prevnext">
    <p><a style="float: left;" href="/ko/docs/Core_JavaScript_1.5_Guide:Operators:Arithmetic_Operators" class="button">« 이전</a><a href="/ko/docs/Core_JavaScript_1.5_Guide:Operators:Logical_Operators" class="button">다음  »</a></p>
</div>
<p></p>
