---
title: Usare i custom elements
slug: Web/Web_Components/Using_custom_elements
translation_of: Web/Web_Components/Using_custom_elements
original_slug: Web/Web_Components/Usare_custom_elements
---
<div><section class="Quick_links" id="Quick_Links"><ol><li class="toggle"><details open><summary>Guides</summary><ol><li><a href="/it/docs/Web/Web_Components/Using_custom_elements">Using custom elements</a> <a href="/it/docs/Web/Web_Components/Using_custom_elements$translate" style="opacity: 0.5;">[Translate]</a></li><li><a href="/it/docs/Web/Web_Components/Using_shadow_DOM">Using shadow DOM</a> <a href="/it/docs/Web/Web_Components/Using_shadow_DOM$translate" style="opacity: 0.5;">[Translate]</a></li><li><a href="/it/docs/Web/Web_Components/Using_templates_and_slots">Using templates and slots</a> <a href="/it/docs/Web/Web_Components/Using_templates_and_slots$translate" style="opacity: 0.5;">[Translate]</a></li></ol></details></li><li class="toggle"><details open><summary>Interfaces</summary><ol><li><a href="/it/docs/Web/API/CustomElementRegistry"><code>CustomElementRegistry</code></a></li><li><a href="/it/docs/Web/API/HTMLSlotElement"><code>HTMLSlotElement</code></a></li><li><a href="/it/docs/Web/API/HTMLTemplateElement"><code>HTMLTemplateElement</code></a></li><li><a href="/it/docs/Web/API/ShadowRoot"><code>ShadowRoot</code></a></li><li><a href="/it/docs/Web/API/DocumentOrShadowRoot"><code>DocumentOrShadowRoot</code></a></li><li><a href="/it/docs/Web/API/Slotable"><code>Slotable</code></a></li></ol></details></li><li class="toggle"><details open><summary>Proprietà</summary><ol><li><a href="/it/docs/Web/API/Element/shadowRoot"><code>Element.shadowRoot</code></a></li><li><a href="/it/docs/Web/API/Element/slot"><code>Element.slot</code></a></li><li><a href="/it/docs/Web/API/Event/composed"><code>Event.composed</code></a></li><li><a href="/it/docs/Web/API/Event/composedPath"><code>Event.composedPath</code></a></li><li><a href="/it/docs/Web/API/Node/isConnected"><code>Node.isConnected</code></a></li><li><a href="/it/docs/Web/API/Window/customElements"><code>Window.customElements</code></a></li></ol></details></li><li class="toggle"><details open><summary>Metodi</summary><ol><li><a href="/it/docs/Web/API/Document/createElement"><code>Document.createElement()</code></a></li><li><a href="/it/docs/Web/API/Element/attachShadow"><code>Element.attachShadow()</code></a></li><li><a href="/it/docs/Web/API/Node/getRootNode"><code>Node.getRootNode()</code></a></li></ol></details></li></ol></section></div>

<p class="summary">Una delle caratteristiche chiave dei Web Components standard è la capacità di creare elementi personalizzati che contengono le funzionalità che vuoi sviluppare direttamente in una pagina HTML, anzichè che sviluppare una lunga serie di singoli elementi innestati per avere, in una pagina, le funzionalità che desideri. Questo articolo ti introduce all&apos;uso delle Custom Elements API.</p>

<div class="note notecard">
<p><strong>Nota</strong>: I custom elements sono supportati di default in Firefox, Chrome, e Edge (76). Opera e Safari fino ad ora supportano solo custom elements proprietari.</p>
</div>

<h2 id="Panoramica_generale">Panoramica generale</h2>

<p>Il controller dei custom elements in un web document è l&apos;oggetto <a href="/it/docs/Web/API/CustomElementRegistry"><code>CustomElementRegistry</code></a> — questo oggetto ti permette di registrareun custom element nella pagina, ritornare informazioni su cosa restituire informazioni su quali elementi personalizzati sono registrati etc.</p>

<p>Per registrare un custom element nella pagina, usa il metodo <a href="/it/docs/Web/API/CustomElementRegistry/define"><code>CustomElementRegistry.define()</code></a>. Questo metodo ha questi argomenti:</p>

<ul>
 <li>Il <a href="/it/docs/Web/API/DOMString"><code>DOMString</code></a> rappresenta il nome che vuoi dare all&apos;elemento. Ricorda che i nomi dei custom elements <a href="https://stackoverflow.com/questions/22545621/do-custom-elements-require-a-dash-in-their-name">richiedono un trattino</a> (kebab-case); non possono essere una singole parole.</li>
 <li>Un oggetto <a href="/en-US/docs/Web/JavaScript/Reference/Classes">classe</a> che definisce le funzionalità dell&apos;elemento.</li>
 <li>Opzionalmente, un oggetto contenente una proprietà <code>extends</code>, che specifica le caratteristiche dell&apos;elemento che vengono ereditate nel custom element creato.</li>
</ul>

<p>Per esempio, possiamo definire un custom <a href="https://mdn.github.io/web-components-examples/word-count-web-component/">word-count element</a> come questo:</p>

<pre class="brush: js">customElements.define(&apos;word-count&apos;, WordCount, { extends: &apos;p&apos; });</pre>

<p>L&apos;elemento è chiamato <code>word-count</code>, la sua classe è <code>WordCount</code>, ed estende l&apos;elemento <a href="/it/docs/Web/HTML/Element/p" title="L&apos;elemento HTML &lt;p&gt; rappresenta un paragrafo di un testo. I paragrafi sono di solito rappresentati in modalità visiva come blocchi di testo che sono separati da blocchi adiacenti da linee di spazio verticali e/o dalla prima linea di indentazione"><code>&lt;p&gt;</code></a>.</p>

<p>Una classe custom element viene scritta usando la sintassi standard ES 2015. Per esempio, <code>WordCount</code> è strutturata così:</p>

<pre class="brush: js">class WordCount extends HTMLParagraphElement {
  constructor() {
    // Always call super first in constructor
    super();

    // Element functionality written in here

    ...
  }
}</pre>

<p>This is just a simple example, but there is more you can do here. It is possible to define specific lifecycle callbacks inside the class, which run at specific points in the element&apos;s lifecycle. For example, <code>connectedCallback</code> is invoked each time the custom element is appended into a document-connected element, while <code>attributeChangedCallback</code> is invoked when one of the custom element&apos;s attributes is added, removed, or changed.</p>

<p>You&apos;ll learn more about these in the <a href="#Using_the_lifecycle_callbacks">Using the lifecycle callbacks</a> section below.</p>

<p>There are two types of custom elements:</p>

<ul>
 <li><strong>Autonomous custom elements</strong> are standalone — they don&apos;t inherit from standard HTML elements. You use these on a page by literally writing them out as an HTML element. For example <code>&lt;popup-info&gt;</code>, or <code>document.createElement(&quot;popup-info&quot;)</code>.</li>
 <li><strong>Customized built-in elements</strong> inherit from basic HTML elements. To create one of these, you have to specify which element they extend (as implied in the examples above), and they are used by writing out the basic element but specifying the name of the custom element in the <code><a href="/it/docs/Web/HTML/Global_attributes#attr-is">is</a></code> attribute (or property). For example <code>&lt;p is=&quot;word-count&quot;&gt;</code>, or <code>document.createElement(&quot;p&quot;, { is: &quot;word-count&quot; })</code>.</li>
</ul>

<h2 id="Working_through_some_simple_examples">Working through some simple examples</h2>

<p>At this point, let&apos;s go through some more simple examples to show you how custom elements are created in more detail.</p>

<h3 id="Autonomous_custom_elements">Autonomous custom elements</h3>

<p>Let&apos;s have a look at an example of an autonomous custom element — <code><a href="https://github.com/mdn/web-components-examples/tree/master/popup-info-box-web-component">&lt;popup-info-box&gt;</a></code> (see a <a href="https://mdn.github.io/web-components-examples/popup-info-box-web-component/">live example</a>). This takes an image icon and a text string, and embeds the icon into the page. When the icon is focused, it displays the text in a pop up information box to provide further in-context information.</p>

<p>To begin with, the JavaScript file defines a class called <code>PopUpInfo</code>, which extends <a href="/it/docs/Web/API/HTMLElement"><code>HTMLElement</code></a>. Autonomous custom elements nearly always extend <code>HTMLElement</code>.</p>

<pre class="brush: js">class PopUpInfo extends HTMLElement {
  constructor() {
    // Always call super first in constructor
    super();

    // write element functionality in here

    ...
  }
}</pre>

<p>The preceding code snippet contains the <code><a href="/en-US/docs/Web/JavaScript/Reference/Classes/constructor">constructor()</a></code> definition for the class, which always starts by calling <code><a href="/en-US/docs/Web/JavaScript/Reference/Operators/super">super()</a></code> so that the correct prototype chain is established.</p>

<p>Inside the constructor, we define all the functionality the element will have when an instance of it is instantiated. In this case we attach a shadow root to the custom element, use some DOM manipulation to create the element&apos;s internal shadow DOM structure — which is then attached to the shadow root — and finally attach some CSS to the shadow root to style it.</p>

<pre class="brush: js">// Create a shadow root
var shadow = this.attachShadow({mode: &apos;open&apos;});

// Create spans
var wrapper = document.createElement(&apos;span&apos;);
wrapper.setAttribute(&apos;class&apos;,&apos;wrapper&apos;);
var icon = document.createElement(&apos;span&apos;);
icon.setAttribute(&apos;class&apos;,&apos;icon&apos;);
icon.setAttribute(&apos;tabindex&apos;, 0);
var info = document.createElement(&apos;span&apos;);
info.setAttribute(&apos;class&apos;,&apos;info&apos;);

// Take attribute content and put it inside the info span
var text = this.getAttribute(&apos;text&apos;);
info.textContent = text;

// Insert icon
var imgUrl;
if(this.hasAttribute(&apos;img&apos;)) {
  imgUrl = this.getAttribute(&apos;img&apos;);
} else {
  imgUrl = &apos;img/default.png&apos;;
}
var img = document.createElement(&apos;img&apos;);
img.src = imgUrl;
icon.appendChild(img);

// Create some CSS to apply to the shadow dom
var style = document.createElement(&apos;style&apos;);

style.textContent = &apos;.wrapper {&apos; +
// CSS truncated for brevity

// attach the created elements to the shadow dom

shadow.appendChild(style);
shadow.appendChild(wrapper);
wrapper.appendChild(icon);
wrapper.appendChild(info);</pre>

<p>Finally, we register our custom element on the <code>CustomElementRegistry</code> using the <code>define()</code> method we mentioned earlier — in the parameters we specify the element name, and then the class name that defines its functionality:</p>

<pre class="brush: js">customElements.define(&apos;popup-info&apos;, PopUpInfo);</pre>

<p>It is now available to use on our page. Over in our HTML, we use it like so:</p>

<pre class="brush: html">&lt;popup-info img=&quot;img/alt.png&quot; text=&quot;Your card validation code (CVC)
  is an extra security feature — it is the last 3 or 4 numbers on the
  back of your card.&quot;&gt;&lt;/popup-info&gt;</pre>

<div class="note notecard">
<p><strong>Note</strong>: You can see the <a href="https://github.com/mdn/web-components-examples/blob/master/popup-info-box-web-component/main.js">full JavaScript source</a> code here.</p>
</div>

<div class="note notecard">
<p><strong>Note</strong>: Remember that for the custom element to work, the script that registers it has to be loaded after the DOM is parsed. This can be done either by including the <code>&lt;script&gt;</code> element at the bottom of the <code>&lt;body&gt;</code>, or by including the <code>defer</code> attribute in your <code>&lt;script&gt;</code> element.</p>
</div>

<h3 id="Internal_vs._external_styles">Internal vs. external styles</h3>

<p>In the above example we apply style to the Shadow DOM using a <a href="/it/docs/Web/HTML/Element/style" title="The documentation about this has not yet been written; please consider contributing!"><code>&lt;style&gt;</code></a> element, but it is perfectly possible to do it by referencing an external stylesheet from a <a href="/it/docs/Web/HTML/Element/link" title="The documentation about this has not yet been written; please consider contributing!"><code>&lt;link&gt;</code></a> element instead.</p>

<p>For example, take a look at this code from our <a href="https://mdn.github.io/web-components-examples/popup-info-box-external-stylesheet/">popup-info-box-external-stylesheet</a> example (see the <a href="https://github.com/mdn/web-components-examples/blob/master/popup-info-box-external-stylesheet/main.js">source code</a>):</p>

<pre class="brush: js">// Apply external styles to the shadow dom
const linkElem = document.createElement(&apos;link&apos;);
linkElem.setAttribute(&apos;rel&apos;, &apos;stylesheet&apos;);
linkElem.setAttribute(&apos;href&apos;, &apos;style.css&apos;);

// Attach the created element to the shadow dom
shadow.appendChild(linkElem);</pre>

<p>Note that <a href="/it/docs/Web/HTML/Element/link" title="The documentation about this has not yet been written; please consider contributing!"><code>&lt;link&gt;</code></a> elements do not block paint of the shadow root, so there may be a flash of unstyled content (FOUC) while the stylesheet loads.</p>

<p>Many modern browsers implement an optimization for <a href="/it/docs/Web/HTML/Element/style" title="The documentation about this has not yet been written; please consider contributing!"><code>&lt;style&gt;</code></a> tags either cloned from a common node or that have identical text, to allow them to share a single backing stylesheet. With this optimization the performance of external and internal styles should be similar.</p>

<h3 id="Customized_built-in_elements">Customized built-in elements</h3>

<p>Now let&apos;s have a look at another customized built in element example — <a href="https://github.com/mdn/web-components-examples/tree/master/expanding-list-web-component">expanding-list</a> (<a href="https://mdn.github.io/web-components-examples/expanding-list-web-component/">see it live also</a>). This turns any unordered list into an expanding/collapsing menu.</p>

<p>First of all, we define our element&apos;s class, in the same manner as before:</p>

<pre class="brush: js">class ExpandingList extends HTMLUListElement {
  constructor() {
    // Always call super first in constructor
    super();

    // write element functionality in here

    ...
  }
}</pre>

<p>We will not explain the element functionality in any detail here, but you can discover how it works by checking out the source code. The only real difference here is that our element is extending the <a href="/it/docs/Web/API/HTMLUListElement"><code>HTMLUListElement</code></a> interface, and not <a href="/it/docs/Web/API/HTMLElement"><code>HTMLElement</code></a>. So it has all the characteristics of a <a href="/it/docs/Web/HTML/Element/ul" title="The documentation about this has not yet been written; please consider contributing!"><code>&lt;ul&gt;</code></a> element with the functionality we define built on top, rather than being a standalone element. This is what makes it a customized built-in, rather than an autonomous element.</p>

<p>Next, we register the element using the <code>define()</code> method as before, except that this time it also includes an options object that details what element our custom element inherits from:</p>

<pre class="brush: js">customElements.define(&apos;expanding-list&apos;, ExpandingList, { extends: &quot;ul&quot; });</pre>

<p>Using the built-in element in a web document also looks somewhat different:</p>

<pre class="brush: html">&lt;ul is=&quot;expanding-list&quot;&gt;

  ...

&lt;/ul&gt;</pre>

<p>You use a <code>&lt;ul&gt;</code> element as normal, but specify the name of the custom element inside the <code>is</code> attribute.</p>

<div class="note notecard">
<p><strong>Note</strong>: Again, you can see the full <a href="https://github.com/mdn/web-components-examples/blob/master/expanding-list-web-component/main.js">JavaScript source code</a> here.</p>
</div>

<h2 id="Using_the_lifecycle_callbacks">Using the lifecycle callbacks</h2>

<p>You can define several different callbacks inside a custom element&apos;s class definition, which fire at different points in the element&apos;s lifecycle:</p>

<ul>
 <li><code>connectedCallback</code>: Invoked each time the custom element is appended into a document-connected element. This will happen each time the node is moved, and may happen before the element&apos;s contents have been fully parsed.

  <div class="note notecard">
  <p><strong>Note</strong>: <code>connectedCallback</code> may be called once your element is no longer connected, use <a href="/it/docs/Web/API/Node/isConnected"><code>Node.isConnected</code></a> to make sure.</p>
  </div>
 </li>
 <li><code>disconnectedCallback</code>: Invoked each time the custom element is disconnected from the document&apos;s DOM.</li>
 <li><code>adoptedCallback</code>: Invoked each time the custom element is moved to a new document.</li>
 <li><code>attributeChangedCallback</code>: Invoked each time one of the custom element&apos;s attributes is added, removed, or changed. Which attributes to notice change for is specified in a static get <code>observedAttributes</code> method</li>
</ul>

<p>Let&apos;s look at an example of these in use. The code below is taken from the <a href="https://github.com/mdn/web-components-examples/tree/master/life-cycle-callbacks">life-cycle-callbacks</a> example (<a href="https://mdn.github.io/web-components-examples/life-cycle-callbacks/">see it running live</a>). This is a trivial example that simply generates a colored square of a fixed size on the page. The custom element looks like this:</p>

<pre class="brush: html">&lt;custom-square l=&quot;100&quot; c=&quot;red&quot;&gt;&lt;/custom-square&gt;</pre>

<p>The class constructor is really simple — here we attach a shadow DOM to the element, then attach empty <a href="/it/docs/Web/HTML/Element/div" title="L&apos;elemento HTML Content Division (&lt;div&gt;) è un contenitore generico per contenuti di flusso. Non ha alcun effetto sui contenuti fin quando non viene stilizzato attraverso CSS. In quanto contenitore &quot;puro&quot;"><code>&lt;div&gt;</code></a> and <a href="/it/docs/Web/HTML/Element/style" title="The documentation about this has not yet been written; please consider contributing!"><code>&lt;style&gt;</code></a> elements to the shadow root:</p>

<pre class="brush: js">var shadow = this.attachShadow({mode: &apos;open&apos;});

var div = document.createElement(&apos;div&apos;);
var style = document.createElement(&apos;style&apos;);
shadow.appendChild(style);
shadow.appendChild(div);</pre>

<p>The key function in this example is <code>updateStyle()</code> — this takes an element, gets its shadow root, finds its <code>&lt;style&gt;</code> element, and adds <a href="/it/docs/Web/CSS/width" title="The documentation about this has not yet been written; please consider contributing!"><code>width</code></a>, <a href="/it/docs/Web/CSS/height" title="The documentation about this has not yet been written; please consider contributing!"><code>height</code></a>, and <a href="/it/docs/Web/CSS/background-color" title="Guida di riferimento ai CSS"><code>background-color</code></a> to the style.</p>

<pre class="brush: js">function updateStyle(elem) {
  const shadow = elem.shadowRoot;
  shadow.querySelector(&apos;style&apos;).textContent = `
    div {
      width: ${elem.getAttribute(&apos;l&apos;)}px;
      height: ${elem.getAttribute(&apos;l&apos;)}px;
      background-color: ${elem.getAttribute(&apos;c&apos;)};
    }
  `;
}</pre>

<p>The actual updates are all handled by the life cycle callbacks, which are placed inside the class definition as methods. The <code>connectedCallback()</code> runs each time the element is added to the DOM — here we run the <code>updateStyle()</code> function to make sure the square is styled as defined in its attributes:</p>

<pre class="brush: js">connectedCallback() {
  console.log(&apos;Custom square element added to page.&apos;);
  updateStyle(this);
}</pre>

<p>The <code>disconnectedCallback()</code> and <code>adoptedCallback()</code> callbacks log simple messages to the console to inform us when the element is either removed from the DOM, or moved to a different page:</p>

<pre class="brush: js">disconnectedCallback() {
  console.log(&apos;Custom square element removed from page.&apos;);
}

adoptedCallback() {
  console.log(&apos;Custom square element moved to new page.&apos;);
}</pre>

<p>The <code>attributeChangedCallback()</code> callback is run whenever one of the element&apos;s attributes is changed in some way. As you can see from its properties, it is possible to act on attributes individually, looking at their name, and old and new attribute values. In this case however, we are just running the <code>updateStyle()</code> function again to make sure that the square&apos;s style is updated as per the new values:</p>

<pre class="brush: js">attributeChangedCallback(name, oldValue, newValue) {
  console.log(&apos;Custom square element attributes changed.&apos;);
  updateStyle(this);
}</pre>

<p>Note that to get the <code>attributeChangedCallback()</code> callback to fire when an attribute changes, you have to observe the attributes. This is done by specifying a <code>static get observedAttributes()</code> method inside custom element class - this should <code>return</code>  an array containing the names of the attributes you want to observe:</p>

<pre class="brush: js">static get observedAttributes() { return [&apos;c&apos;, &apos;l&apos;]; }</pre>

<p>This is placed right at the top of the constructor, in our example.</p>

<div class="note notecard">
<p><strong>Note</strong>: Find the <a href="https://github.com/mdn/web-components-examples/blob/master/life-cycle-callbacks/main.js">full JavaScript source</a> here.</p>
</div>

<h2 id="Polyfills_vs._classes">Polyfills vs. classes</h2>

<p>Custom Element polyfills may patch native constructors such as <code>HTMLElement</code> and others, and return a different instance from the one just created.</p>

<p>If you need a <code>constructor</code> and a mandatory <code>super</code> call, remember to pass along optional arguments and return the result of such a <code>super</code> call operation.</p>

<pre class="brush: js">class CustomElement extends HTMLElement {
  constructor(...args) {
    const self = super(...args);
    // self functionality written in here
    // self.addEventListener(...)
    // return the right context
    return self;
  }
}</pre>

<p>If you don&apos;t need to perform any operation in the constructor, you can simply omit it so that its native behavior (see following) will be preserved.</p>

<pre class="brush: js"> constructor(...args) { return super(...args); }
</pre>

<h2 id="Transpilers_vs._classes">Transpilers vs. classes</h2>

<p>Please note that ES2015 classes cannot reliably be transpiled in Babel 6 or TypeScript targeting legacy browsers. You can either use Babel 7 or the <a href="https://www.npmjs.com/package/babel-plugin-transform-builtin-classes">babel-plugin-transform-builtin-classes</a> for Babel 6, and target ES2015 in TypeScript instead of legacy.</p>

<h2 id="Libraries">Libraries</h2>

<p>There are several libraries that are built on Web Components with the aim of increasing the level of abstraction when creating custom elements. Some of these libraries are <a href="https://github.com/devpunks/snuggsi" rel="nofollow">snuggsi ツ</a>, <a href="https://x-tag.github.io/" rel="nofollow">X-Tag</a>, <a href="http://slimjs.com/" rel="nofollow">Slim.js</a>, <a href="https://lit-element.polymer-project.org/">LitElement</a>, <a href="https://www.htmlelements.com/">Smart</a>, and <a href="https://stenciljs.com">Stencil</a>.</p>
