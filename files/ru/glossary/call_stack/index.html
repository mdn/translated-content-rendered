---
title: Call stack
slug: Glossary/Call_stack
tags:
  - Glossary
translation_of: Glossary/Call_stack
original_slug: Словарь/Call_stack
---
<p><strong>Стек вызовов(call stack) </strong>- это механизм для интерпретаторов (таких как интерпретатор JavaScript в веб-браузере) для отслеживания текущего местонахождения интерпретатора в скрипте, который вызывает  несколько функций типа <a class="glossaryLink" href="/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F" title="functions: Анонимная функция это функция без имени:">functions</a>, — какая из функций выполняется на данный момент, какие функции вызываются изнутри этой (выполняемой) функции, какая будет вызвана следующей и т. д.</p>

<ul>
 <li>Когда скрипт вызывает функцию, интерпретатор добавляет ее в стек вызовов и потом начинает ее обработку.</li>
 <li>Любые функции, вызванные этой функцией, добавляются в  стек вызовов и выполняются, как только происходит их вызов. </li>
 <li>Когда выполнение основной функции завершено, интрепретатор снимает ее со стека вызовов и возобновляет выполнение кода в списке основного кода с той точки, где остановился до этого.</li>
 <li>Если стек занимает больше места, чем ему было присвоено, это приводит к ошибке переполнения стека (&quot;stack overflow&quot; error).</li>
</ul>

<h2 id="Пример">Пример</h2>

<p> </p>

<pre class="brush: js">function greeting() {
   // [1] Some codes here
   sayHi();
   // [2] Some codes here
}
function sayHi() {
   return &quot;Hi!&quot;;
}

// Invoke the `greeting` function
greeting();

// [3] Some codes here</pre>

<p>Код выше будет выполнен следующим образом:</p>

<ol>
 <li>Игнорирование всех функций, пока не будет достигнуто место вызова функции <code>greeting()</code>.</li>
 <li>Вызывается функция <code>greeting().</code></li>
 <li>Функция &quot;greeting&quot; помещается в очередь стека вызовов.</li>
</ol>

<div class="note notecard">
<p>Очередь стека вызовов:<br>
 - greeting</p>
</div>

<p> </p>

<ol start="4">
 <li>Выполняется код внутри функции `greeting`.</li>
 <li>Вызывается функция <code>sayHi()</code>.</li>
 <li>Функция <code>sayHi()</code> помещается в очередь стека вызовов.</li>
</ol>

<div class="note notecard">
<p>Очередь стека вызовов:<br>
 - greeting<br>
 - sayHi</p>
</div>

<ol start="7">
 <li>Выполняется весь код внутри функции <code>sayHi()</code> до самого конца.</li>
 <li>Возврат выполнения кода  с места вызова функции <code>sayHi()</code> и продолжение выполнения оставшегося кода функции <code>greeting()</code>.</li>
 <li>Выполненная функция <code>sayHi()</code> удаляется из очереди стека вызовов.<br>

  <div class="note notecard">
  <p>Очередь стека вызовов:<br>
   - greeting</p>
  </div>
 </li>
 <li>Когда весь код внутри функции <code>greeting()</code> выполнен, происходит возврат выполнения оставшейся части основного скрипта JS с места вызова функции <code>greeting()</code>.</li>
 <li>Выполненная функция <code>greeting()</code> удаляется из очереди стека вызовов.<br>

  <div class="note notecard">
  <p>Очередь стека вызовов:<br>
   ПУСТО</p>
  </div>
 </li>
</ol>

<p>Выполнение кода началось с пустого стека вызовов, и всякий раз, когда мы вызывали функцию, она автоматически добавлялась в очередь стека вызовов, после выполнения всего своего кода она автоматически удалялась из очереди стека вызовов. И в конце выполнение кода также завершилось с пустым стеком вызовов.</p>

<h2 id="Узнать_больше">Узнать больше</h2>

<h3 id="Общие_знания">Общие знания</h3>

<ul>
 <li><a href="https://ru.wikipedia.org/wiki/Call stack">Call stack</a> на Википедии</li>
</ul>

<section id="Quick_Links">
<ul>
 <li><a href="/ru/docs/Glossary">MDN Web Docs Glossary</a>

  <ul>
   <li><a class="glossaryLink" href="/ru/docs/Словарь/Call_stack">Call stack</a></li>
   <li><a class="glossaryLink" href="/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F">Function</a></li>
  </ul>
 </li>
</ul>
</section>
