---
title: Применение стилей и цветов
slug: Web/API/Canvas_API/Tutorial/Applying_styles_and_colors
translation_of: Web/API/Canvas_API/Tutorial/Applying_styles_and_colors
original_slug: Web/API/Canvas_API/Tutorial/Применение_стилей_и_цветов
---
<div><section id="Quick_Links">
 <ol>
  <li><a href="/ru/docs/Web/API/Canvas_API"><strong>Canvas API</strong></a></li>
  <li class="toggle">
    <details open>
      <summary>Руководство по Canvas</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Basic_usage">Базовое использование</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes">Рисование фигур</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors">Применение стилей и цветов</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Drawing_text">Рисование текста</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Using_images">Использование изображений</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Transformations">Трансформации</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Compositing">Композиция и обрезка</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Basic_animations">Простые анимации</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Advanced_animations">Расширенные анимации</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas">Манипуляция пикселями</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Hit_regions_and_accessibility">Достижение областей и доступность</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas">Оптимизация canvas</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Finale">Заключение</a></li>
        </ol>
    </details>
  </li>
  <li class="toggle">
    <details open>
      <summary>Примеры</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/Canvas_API/A_basic_ray-caster">Простой излучатель лучей</a></li>
        <li><a href="/ru/Add-ons/Code_snippets/Canvas">Спиппеты кода Canvas</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Manipulating_video_using_canvas">Манипяция видео с помощью canvas</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details open>
      <summary>Интерфейсы</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/HTMLCanvasElement"><code>HTMLCanvasElement</code></a></li>
        <li><a href="/ru/docs/Web/API/CanvasRenderingContext2D"><code>CanvasRenderingContext2D</code></a></li>
        <li><a href="/ru/docs/Web/API/CanvasGradient"><code>CanvasGradient</code></a></li>
        <li><a href="/ru/docs/Web/API/CanvasPattern"><code>CanvasPattern</code></a></li>
        <li><a href="/ru/docs/Web/API/ImageBitmap"><code>ImageBitmap</code></a></li>
        <li><a href="/ru/docs/Web/API/ImageData"><code>ImageData</code></a></li>
        <li><a href="/ru/docs/Web/API/TextMetrics"><code>TextMetrics</code></a></li>
        <li><span class="sidebar-icon"><span class="icon-only-inline" title="Это экспериментальное API, которое не должно использоваться в рабочем коде."><i class="icon-beaker"> </i></span></span> <a href="/ru/docs/Web/API/Path2D"><code>Path2D</code></a></li>
      </ol>
    </details>
  </li>
  <li><strong><a href="/ru/docs/MDN">Документация:</a></strong></li>
  <li class="toggle">
    <details>
      <summary>Полезные списки</summary>
      <ol>
        <li><a href="/ru/docs/tag/Canvas">Страницы отмеченные &quot;Canvas&quot;</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details>
      <summary>Внести свой вклад</summary>
      <ol>
        <li><a href="/ru/docs/MDN/Doc_status/API/Canvas">Статус документации по Canvas</a></li>
        <li><a href="/ru/docs/MDN">Проект MDN</a></li>
      </ol>
    </details>
  </li>
 </ol>
</section> <div class="prevnext" style="text-align: right;">
    <p><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes" style="float: left;" class="button">« Предыдущая статья</a><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Drawing_text" class="button">Следующая статья  »</a></p>
</div></div>

<div class="summary">
<p>В главе о <a href="/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes" title="Web/Guide/HTML/Canvas_tutorial/Drawing_shapes">рисовании фигур</a>, <span id="result_box" lang="ru"><span>мы использовали</span></span><span lang="ru"><span class="hps"> для линий</span> <span class="hps">и</span><span class="hps"> заполнения</span> <span class="hps">только</span> <span class="hps">стили<span> </span>по умолчанию</span><span>.</span></span> <span id="result_box" lang="ru"><span class="hps">Здесь</span> <span class="hps">мы будем исследовать</span> <span class="hps">опции </span></span>canvas<span lang="ru">, которые <span class="hps">мы</span> <span class="hps">имеем в нашем</span> <span class="hps">распоряжении, чтобы сделать</span> <span class="hps">наши</span> <span class="hps">рисунки</span> <span class="hps">немного</span> <span class="hps">более привлекательными. </span></span><span id="result_box" lang="ru"><span class="hps">Вы узнаете, как</span> <span class="hps">добавлять различные</span> <span class="hps">цвета,</span> <span class="hps">стили линий</span><span>, градиенты</span><span>, узоры</span> <span class="hps">и тени</span> <span class="hps">вашим рисункам</span><span>.</span></span></p>
</div>

<h2 id="Colors" name="Colors">Цвета</h2>

<p><span id="result_box" lang="ru"><span class="hps">До сих пор</span> <span class="hps">мы</span> <span class="hps">видели только</span> <span class="hps">методы</span> <span class="hps">рисования контекста. </span></span><span id="result_box" lang="ru"><span class="hps">Если</span> <span class="hps">мы хотим применить</span> <span class="hps">цвета</span> <span class="hps">к фигуре</span><span>,</span> то <span class="hps">есть два важных</span> <span class="hps">свойства</span>, которые <span class="hps">мы можем</span> <span class="hps">использовать:</span></span> <code>fillStyle</code> и <code>strokeStyle</code>.</p>

<dl>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/fillStyle"><code>fillStyle = color</code></a></dt>
 <dd>Устанавливает стиль для фона фигур.</dd>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/strokeStyle"><code>strokeStyle = color</code></a></dt>
 <dd>Устанавливает стиль контура фигуры. </dd>
</dl>

<p><em><code>color </code></em>может быть цветом, (<code>строка, представленная в</code> CSS <a href="/ru/docs/Web/CSS/color_value" title="Тип &lt;color&gt; CSS data type предоставляет цвте в цветовом спектре sRGB. В  &lt;color&gt; может включять значения прозрачности Альфа-канала (alpha-channel), уыказывающие, как цвет сочетаеться с его фоном."><code>&lt;color&gt;</code></a>), градиентом или паттерном. Градиенты и паттерны мы рассмотрим позже. По умолчанию цвет фона и контура  — черный (значение CSS цвета  <code>#000000</code>).</p>

<div class="note notecard">
<p><strong>На заметку:</strong> Когда вы устанавливаете  значения <code>strokeStyle</code> и/или <code>fillStyle</code>, то новое значение становится стандартным для всех фигур, которые будут нарисованы с этого момента. Когда вам нужен другой цвет, вы должны перезаписать значение в <code>fillStyle</code> или в <code>strokeStyle</code> для каждой фигуры.</p>
</div>

<p>Чтобы строка <em><code>color </code></em>считалась валидной, она должна соответствовать CSS <a href="/ru/docs/Web/CSS/color_value" title="Тип &lt;color&gt; CSS data type предоставляет цвте в цветовом спектре sRGB. В  &lt;color&gt; может включять значения прозрачности Альфа-канала (alpha-channel), уыказывающие, как цвет сочетаеться с его фоном."><code>&lt;color&gt;</code></a>. Далее приведены примеры того, как можно по-разному задать один и тот же цвет. </p>

<pre class="brush: js notranslate">// these all set the fillStyle to &apos;orange&apos;

ctx.fillStyle = &quot;orange&quot;;
ctx.fillStyle = &quot;#FFA500&quot;;
ctx.fillStyle = &quot;rgb(255,165,0)&quot;;
ctx.fillStyle = &quot;rgba(255,165,0,1)&quot;;
</pre>

<h3 id="Пример_fillStyle">Пример <code>fillStyle</code></h3>

<p>В этом примере мы опять воспользуемся двойным циклом, чтобы нарисовать сетку из прямоугольников, каждый из которых имеет свой цвет. Окончательное изображение должно иметь вид, как показано на скриншоте. Здесь не происходит ничего сверхъестественного. Мы используем две переменные <code>i</code> и <code>j</code> для генерации уникального RGB цвета для каждого квадрата и изменяем только красные и зеленые значения. Синий канал представляет собой фиксированное значение. Путем изменения каналов вы можете генерировать всю палитру. Увеличив количество шагов вы можете достигнуть такого вида палитры, какая используется в Photoshop.</p>

<pre class="brush: js;highlight[5,6] notranslate">function draw() {
  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);
  for (var i=0;i&lt;6;i++){
    for (var j=0;j&lt;6;j++){
      ctx.fillStyle = &apos;rgb(&apos; + Math.floor(255-42.5*i) + &apos;,&apos; +
                       Math.floor(255-42.5*j) + &apos;,0)&apos;;
      ctx.fillRect(j*25,i*25,25,25);
    }
  }
}</pre>

<div class="hidden">
<pre class="brush: html notranslate">&lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;</pre>

<pre class="brush: js notranslate">draw();</pre>
</div>

<p>Результат выглядит так:</p>

<table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img alt class="internal" src="https://mdn.mozillademos.org/files/5417/Canvas_fillstyle.png"></td><td><iframe class="live-sample-frame sample-code-frame" frameborder="0" height="160" id="frame_Пример_fillStyle" src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D1%82%D0%B8%D0%BB%D0%B5%D0%B9_%D0%B8_%D1%86%D0%B2%D0%B5%D1%82%D0%BE%D0%B2$samples/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_fillStyle?revision=1629489" width="160"></iframe></td></tr></tbody></table>

<h3 id="Пример_strokeStyle">Пример <code>strokeStyle</code></h3>

<p>Этот пример похож на предыдущий, но мы используем свойство <code>strokeStyle</code> чтобы изменить цвета очертаний фигур. Так же мы используем метод <code>arc()</code> для рисования окружностей вместо квадратов.</p>

<pre class="brush: js;highlight[5,6] notranslate">  function draw() {
    var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);
    for (var i=0;i&lt;6;i++){
      for (var j=0;j&lt;6;j++){
        ctx.strokeStyle = &apos;rgb(0,&apos; + Math.floor(255-42.5*i) + &apos;,&apos; +
                         Math.floor(255-42.5*j) + &apos;)&apos;;
        ctx.beginPath();
        ctx.arc(12.5+j*25,12.5+i*25,10,0,Math.PI*2,true);
        ctx.stroke();
      }
    }
  }
</pre>

<div class="hidden">
<pre class="brush: html notranslate">&lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;</pre>

<pre class="brush: js notranslate">draw();</pre>
</div>

<p>Результат выглядит так:</p>

<table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img alt class="internal" src="https://mdn.mozillademos.org/files/253/Canvas_strokestyle.png"></td><td><iframe class="live-sample-frame sample-code-frame" frameborder="0" height="180" id="frame_Пример_strokeStyle" src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D1%82%D0%B8%D0%BB%D0%B5%D0%B9_%D0%B8_%D1%86%D0%B2%D0%B5%D1%82%D0%BE%D0%B2$samples/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_strokeStyle?revision=1629489" width="180"></iframe></td></tr></tbody></table>

<h2 id="Transparency" name="Transparency">Прозрачность</h2>

<p>В дополнении к рисованию непрозрачных фигур, мы также можем рисовать прозрачные (полупрозрачные) фигуры.  Это делается через установку свойства <code>globalAlpha</code> или задачи полупрозрачного цвета фона или контура.</p>

<dl>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/globalAlpha"><code>globalAlpha = transparencyValue</code></a></dt>
 <dd>Для применения, указывается значения прозрачности для всех будущих фигур, что будут нарисованы на canvas. Значение полупрозрачности могут быть между 0.0 (полная прозрачность) и 1.0 (полная непрозрачность). Значение 1.0 (полная непрозрачность) установлено по умолчанию.</dd>
</dl>

<p>Свойство <code>globalAlpha</code> может быть использовано, если вы хотите рисовать формы с одинаковой прозрачностью, но в иной ситуации, обычно устанавливают прозрачность индивидуально к каждой форме, когда указывают их цвет.</p>

<p>Так как свойства <code>strokeStyle</code> и <code>fillStyle</code> принимают цветовые значения rgba через CSS, мы можем использовать следующее обозначение  для назначения прозрачных цветов.</p>

<pre class="brush: js notranslate">// Assigning transparent colors to stroke and fill style

ctx.strokeStyle = &quot;rgba(255,0,0,0.5)&quot;;
ctx.fillStyle = &quot;rgba(255,0,0,0.5)&quot;;
</pre>

<p>Функция <code>rgba()</code> похожа на функцию <code>rgb()</code>, но имеет один дополнительный параметр. Последний параметр устанавливает значение прозрачности для конкретного цвета. Действующий диапозон значений находится между 0.0 (полная прозрачность) и 1.0 (полная непрозрачность).</p>

<h3 id="Пример_globalAlpha">Пример <code>globalAlpha</code></h3>

<p>В данном примере мы нарисуем фон и четыре квадрата с различными цветами.  Сверху изображения будет выведен набор полупрозрачных кругов. Установим свойство <code>globalAlpha</code> значением 0.2, которое будет использовано для всех последующих форм. Каждый шаг цикла рисует круг с большим радиусом. По окончанию получим радиальный градиент. Накладывая еще больше кругов друг на друга, мы фактически сможем уменьшить прозрачность ранее нарисованных кругов. Увеличив счетчик итераций, при этом рисуя еще круги, мы сможем добиться исчезновение центра изображения.</p>

<pre class="brush: js;highlight[15] notranslate">function draw() {
  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);
  // фон изображения
  ctx.fillStyle = &apos;#FD0&apos;;
  ctx.fillRect(0,0,75,75);
  ctx.fillStyle = &apos;#6C0&apos;;
  ctx.fillRect(75,0,75,75);
  ctx.fillStyle = &apos;#09F&apos;;
  ctx.fillRect(0,75,75,75);
  ctx.fillStyle = &apos;#F30&apos;;
  ctx.fillRect(75,75,75,75);
  ctx.fillStyle = &apos;#FFF&apos;;

  // устанавливаем значение прозрачности
  ctx.globalAlpha = 0.2;

  // Рисуем полупрозрачные круги
  for (i=0;i&lt;7;i++){
    ctx.beginPath();
    ctx.arc(75,75,10+10*i,0,Math.PI*2,true);
    ctx.fill();
  }
}</pre>

<div class="hidden">
<pre class="brush: html notranslate">&lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;</pre>

<pre class="brush: js notranslate">draw();</pre>
</div>

<table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img alt class="internal" src="https://mdn.mozillademos.org/files/232/Canvas_globalalpha.png"></td><td><iframe class="live-sample-frame sample-code-frame" frameborder="0" height="180" id="frame_Пример_globalAlpha" src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D1%82%D0%B8%D0%BB%D0%B5%D0%B9_%D0%B8_%D1%86%D0%B2%D0%B5%D1%82%D0%BE%D0%B2$samples/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_globalAlpha?revision=1629489" width="180"></iframe></td></tr></tbody></table>

<h3 id="Пример_использования_rgba">Пример использования <code>rgba()</code></h3>

<p>В этом втором примере мы делаем что-то похожее на предыдущее, но вместо рисования кругов друг над другом, я рисовал маленькие прямоугольники с увеличением непрозрачности. Использование <code>rgba()</code> добавляет контроля и гибкости, поскольку мы можем индивидуально настраивать стиль заливки и штриха.</p>

<pre class="brush: js;highlight[16] notranslate">function draw() {
  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);

  // Нарисовать фон
  ctx.fillStyle = &apos;rgb(255,221,0)&apos;;
  ctx.fillRect(0,0,150,37.5);
  ctx.fillStyle = &apos;rgb(102,204,0)&apos;;
  ctx.fillRect(0,37.5,150,37.5);
  ctx.fillStyle = &apos;rgb(0,153,255)&apos;;
  ctx.fillRect(0,75,150,37.5);
  ctx.fillStyle = &apos;rgb(255,51,0)&apos;;
  ctx.fillRect(0,112.5,150,37.5);

  // Нарисовать полупрозрачные прямоугольники
  for (var i=0;i&lt;10;i++){
    ctx.fillStyle = &apos;rgba(255,255,255,&apos;+(i+1)/10+&apos;)&apos;;
    for (var j=0;j&lt;4;j++){
      ctx.fillRect(5+i*14,5+j*37.5,14,27.5);
    }
  }
}</pre>

<div class="hidden">
<pre class="brush: html notranslate">&lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;</pre>

<pre class="brush: js notranslate">draw();</pre>
</div>

<table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img alt class="internal" src="https://mdn.mozillademos.org/files/246/Canvas_rgba.png"></td><td><iframe class="live-sample-frame sample-code-frame" frameborder="0" height="180" id="frame_Пример_использования_rgba()" src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D1%82%D0%B8%D0%BB%D0%B5%D0%B9_%D0%B8_%D1%86%D0%B2%D0%B5%D1%82%D0%BE%D0%B2$samples/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_rgba()?revision=1629489" width="180"></iframe></td></tr></tbody></table>

<h2 id="Line_styles" name="Line_styles">Стили линий</h2>

<p>Есть несколько свойств, которые позволяют нам стилизовать линии.</p>

<dl>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/lineWidth"><code>lineWidth = value</code></a></dt>
 <dd>Устанавливает ширину линий, рисуемых в будущем.</dd>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/lineCap"><code>lineCap = type</code></a></dt>
 <dd>Устанавливает внешний вид концов линий.</dd>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/lineJoin"><code>lineJoin = type</code></a></dt>
 <dd>Устанавливает внешний вид «углов», где встречаются линии.</dd>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/miterLimit"><code>miterLimit = value</code></a></dt>
 <dd>Устанавливает ограничение на митру, когда две линии соединяются под острым углом, чтобы вы могли контролировать её толщину.</dd>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/getLineDash"><code>getLineDash()</code></a></dt>
 <dd>Возвращает текущий массив тире штриховки, содержащий четное число неотрицательных чисел.</dd>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/setLineDash"><code>setLineDash(segments)</code></a></dt>
 <dd>Устанавливает текущий пунктир линии.</dd>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/lineDashOffset"><code>lineDashOffset = value</code></a></dt>
 <dd>Указывает, где следует начинать тире массива в строке.</dd>
</dl>

<p>Вы лучше поймете, что они делают, глядя на приведенные ниже примеры.</p>

<h3 id="Пример_lineWidth">Пример <code>lineWidth</code></h3>

<p>Это свойство задает толщину текущей строки. Значения должны быть положительными. По умолчанию для этого значения установлено 1.0 единицы.</p>

<p>Ширина линии - это толщина хода, центрированного по данному пути. Другими словами, область, которая нарисована, простирается до половины ширины линии по обе стороны пути. Поскольку координаты холста не напрямую ссылаются на пиксели, особое внимание следует уделять получению четких горизонтальных и вертикальных линий.</p>

<p>В приведенном ниже примере 10 прямых линий рисуются с увеличением ширины линий. Линия в крайнем левом углу - 1.0 единицы. Тем не менее, толщина левой и всех других линий нечетной ширины не выглядят четкими из-за позиционирования пути.</p>

<pre class="brush: js;highlight[4] notranslate">function draw() {
  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);
  for (var i = 0; i &lt; 10; i++){
    ctx.lineWidth = 1+i;
    ctx.beginPath();
    ctx.moveTo(5+i*14,5);
    ctx.lineTo(5+i*14,140);
    ctx.stroke();
  }
}
</pre>

<div class="hidden">
<pre class="brush: html notranslate">&lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;</pre>

<pre class="brush: js notranslate">draw();</pre>
</div>

<table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img alt class="internal" src="https://mdn.mozillademos.org/files/239/Canvas_linewidth.png"></td><td><iframe class="live-sample-frame sample-code-frame" frameborder="0" height="180" id="frame_Пример_lineWidth" src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D1%82%D0%B8%D0%BB%D0%B5%D0%B9_%D0%B8_%D1%86%D0%B2%D0%B5%D1%82%D0%BE%D0%B2$samples/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_lineWidth?revision=1629489" width="180"></iframe></td></tr></tbody></table>

<p>Получение четких строк требует понимания путей сглаживания. На рисунках ниже представлена сетка координат холста. Квадраты между сетками являются фактическими экранными пикселями. В первом изображении сетки ниже прямоугольник от (2, 1) до (5, 5) заполняется. Вся область между ними (светло-красный) падает на границы пикселей, поэтому полученный заполненный прямоугольник будет иметь четкие края.</p>

<p><img alt class="internal" src="https://mdn.mozillademos.org/files/201/Canvas-grid.png"></p>

<p>Если вы рассмотрите путь от (3, 1) до (3, 5) с толщиной строки <code>1.0</code>, вы получите ситуацию во втором изображении. Фактическая заполняемая область, (синяя), распространяется только наполовину в пикселях по обе стороны пути. Приблизительно это означает, что частично затенённые пиксели приводят к заполнению всей области (светло-голубой и синей) цветом, только наполовину темным, чем фактический цвет штриха. Это то, что происходит с линией шириной <code>1.0</code> в предыдущем примере кода.</p>

<p>Чтобы исправить это, вы должны быть более точными при создании пути. Зная, что линия шириной <code>1.0</code> занимает половину единицы по обе стороны пути, создание пути от (3.5, 1) до (3.5, 5) приведёт к ситуации в третьем изображении - ширина линии <code>1.0</code> закончится верно, точно заполняя вертикальную линию с одним пикселем.</p>

<div class="note notecard">
<p><strong>Примечание:</strong> Имейте в виду, что в нашем примере с вертикальной линией позиция Y по-прежнему ссылается на целочисленную позицию сетки - иначе мы увидели бы пиксели с половинным охватом в конечных точках (также обратите внимание, что это поведение зависит от текущего стиля <code>lineCap</code>,  значение по умолчанию - <code>butt</code>; вы можете вычислить согласованные штрихи с полупиксельными координатами для линий с нечетной шириной, установив стиль <code>lineCap</code> в <code>square</code>, чтобы внешняя граница вокруг конечной точки линии автоматически расширялась, охватывая весь пиксель в точку).</p>

<p>Также обратите внимание, что затронуты только начальные и конечные  точки пути: если путь закрыт с помощью <code>closePath()</code>, - нет начальной и конечной точки; вместо этого все конечные точки в пути подключены к их прикрепленному предыдущему и следующему сегментам и при текущей настройке стиля <code>lineJoin</code> в значении по умолчанию - <code>miter</code>, с эффектом автоматического расширения внешних границ подключенных сегментов до их точки пересечения - обработанный ход будет точно покрывать полные пиксели с центром в каждой конечной точке, если эти связанные сегменты горизонтальны и/или вертикальны). См. следующие два раздела, демонстрирующие эти дополнительные стили.</p>
</div>

<p>Для линий с четной шириной каждая половина заканчивается как целое количество пикселей, поэтому вам нужен путь, который находится между пикселями (то есть (3,1) - (3,5)), вместо середины пикселей.</p>

<p>Хотя это и необычно, когда изначально работаешь с масштабируемой 2D-графикой, обращая внимание на сетку пикселей и положение путей, но вы убедитесь, что ваши рисунки будут выглядеть правильно, независимо от масштабирования или любых других преобразований. Вертикальная линия ширины 1,0, построенная таким образом, станет четкой 2-пиксельной линией при увеличении на 2 и появится в правильном положении.</p>

<h3 id="Пример_lineCap">Пример <code>lineCap</code></h3>

<p>Свойство <code>lineCap</code> определяет, как выводятся конечные точки каждой строки. Для этого свойства есть три возможных значения: <code>butt</code>, <code>round</code> и <code>square</code>. По умолчанию для этого свойства установлено значение <code>butt</code>.</p>

<p><img alt src="https://mdn.mozillademos.org/files/236/Canvas_linecap.png" style="float: right; height: 190px; width: 190px;"></p>

<dl>
 <dt><code>butt</code></dt>
 <dd>Концы линий соответствуют крайним точкам.</dd>
 <dt><code>round</code></dt>
 <dd>Концы линий округлены.</dd>
 <dt><code>square</code></dt>
 <dd>Концы линий описаны квадратом с равной шириной и половиной высоты толщины линии.</dd>
</dl>

<p>В этом примере мы проведем три строки, каждая из которых имеет другое значение для свойства <code>lineCap</code>. Я также добавил два руководства, чтобы увидеть точные различия между ними. Каждая из этих линий начинается и заканчивается именно на этих направляющих.</p>

<p>Строка слева использует <code>butt</code> опцию по умолчанию. Вы заметите, что она полностью очищена от направляющих. Второй вариант -  <code>round</code> опция. Это добавляет полукруг к концу, который имеет радиус, равный половине ширины линии. Строка справа использует <code>square</code> опцию. Это добавляет поле с равной шириной и половиной высоты толщины линии.</p>

<pre class="brush: js;highlight[18] notranslate">function draw() {
  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);
  var lineCap = [&apos;butt&apos;,&apos;round&apos;,&apos;square&apos;];

  // Draw guides
  ctx.strokeStyle = &apos;#09f&apos;;
  ctx.beginPath();
  ctx.moveTo(10,10);
  ctx.lineTo(140,10);
  ctx.moveTo(10,140);
  ctx.lineTo(140,140);
  ctx.stroke();

  // Draw lines
  ctx.strokeStyle = &apos;black&apos;;
  for (var i=0;i&lt;lineCap.length;i++){
    ctx.lineWidth = 15;
    ctx.lineCap = lineCap[i];
    ctx.beginPath();
    ctx.moveTo(25+i*50,10);
    ctx.lineTo(25+i*50,140);
    ctx.stroke();
  }
}
</pre>

<div class="hidden">
<pre class="brush: html notranslate">&lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;</pre>

<pre class="brush: js notranslate">draw();</pre>
</div>

<table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img alt class="internal" src="https://mdn.mozillademos.org/files/236/Canvas_linecap.png"></td><td><iframe class="live-sample-frame sample-code-frame" frameborder="0" height="180" id="frame_Пример_lineCap" src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D1%82%D0%B8%D0%BB%D0%B5%D0%B9_%D0%B8_%D1%86%D0%B2%D0%B5%D1%82%D0%BE%D0%B2$samples/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_lineCap?revision=1629489" width="180"></iframe></td></tr></tbody></table>

<h3 id="Пример_lineJoin">Пример <code>lineJoin</code></h3>

<p>Свойство <code>lineJoin</code> определяет, как соединяются два сегмента (линий, дуг или кривых) с ненулевой длиной в форме (вырожденные сегменты с нулевой длиной, заданные конечные точки и контрольные точки находятся точно в том же положении - пропущены).</p>

<p>Для этого свойства есть три возможных значения: <code>round</code>, <code>bevel</code> и <code>miter</code>. По умолчанию для этого свойства установлено значение <code>miter</code>. Обратите внимание, что настройка <code>lineJoin</code> не действует, если два связанных сегмента имеют одно и то же направление, потому что в этом случае не будет добавлена ​​область соединения.</p>

<p><img alt src="https://mdn.mozillademos.org/files/237/Canvas_linejoin.png" style="float: right; height: 190px; width: 190px;"></p>

<dl>
 <dt><code>round</code></dt>
 <dd>Радиус заполняемой части для скругленных углов равен половине ширины линии. центр этого радиуса совпадает с концами подключенных сегментов.</dd>
 <dt><code>bevel</code></dt>
 <dd>Заполняет дополнительную треугольную область между общей конечной точкой подключенных сегментов и отдельными внешними прямоугольными углами каждого сегмента. </dd>
 <dt><code>miter</code></dt>
 <dd>Подключенные сегменты соединяются путем расширения их внешних краев для соединения в одной точке с эффектом заполнения дополнительной области в форме пастилки. Эта настройка выполняется с помощью свойства <code>miterLimit</code>, которое объясняется ниже.</dd>
</dl>

<p>В приведенном ниже примере показаны три разных пути, демонстрирующие каждый из этих трех свойств <code>lineJoin</code>; результат - выше. </p>

<pre class="brush: js;highlight[6] notranslate">function draw() {
  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);
  var lineJoin = [&apos;round&apos;,&apos;bevel&apos;,&apos;miter&apos;];
  ctx.lineWidth = 10;
  for (var i=0;i&lt;lineJoin.length;i++){
    ctx.lineJoin = lineJoin[i];
    ctx.beginPath();
    ctx.moveTo(-5,5+i*40);
    ctx.lineTo(35,45+i*40);
    ctx.lineTo(75,5+i*40);
    ctx.lineTo(115,45+i*40);
    ctx.lineTo(155,5+i*40);
    ctx.stroke();
  }
}
</pre>

<div class="hidden">
<pre class="brush: html notranslate">&lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;</pre>

<pre class="brush: js notranslate">draw();</pre>
</div>

<table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img alt class="internal" src="https://mdn.mozillademos.org/files/237/Canvas_linejoin.png"></td><td><iframe class="live-sample-frame sample-code-frame" frameborder="0" height="180" id="frame_Пример_lineJoin" src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D1%82%D0%B8%D0%BB%D0%B5%D0%B9_%D0%B8_%D1%86%D0%B2%D0%B5%D1%82%D0%BE%D0%B2$samples/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_lineJoin?revision=1629489" width="180"></iframe></td></tr></tbody></table>

<h3 id="Демонстрация_свойства_miterLimit">Демонстрация свойства <code>miterLimit</code></h3>

<p>Как вы видели в предыдущем примере, при объединении двух строк с опцией <code>miter</code> внешние края двух соединительных линий расширены до точки, где они встречаются. Для линий, которые находятся под большими углами друг с другом, эта точка находится недалеко от внутренней точки соединения. Однако, поскольку углы между каждой линией уменьшаются, расстояние (длина меча) между этими точками увеличивается экспоненциально.</p>

<p>Свойство <code>miterLimit</code> определяет, как далеко можно установить внешнюю точку соединения из внутренней точки подключения. Если две линии превышают это значение, вместо этого получается привязка конуса. Обратите внимание, что максимальная длина митра является произведением ширины линии, измеренной в текущей системе координат, значением этого свойства <code>miterLimit</code> (значение по умолчанию 10,0 в HTML <a href="/ru/docs/Web/HTML/Element/canvas" title="HTML &lt;canvas&gt; Элемент может быть использован для отрисовки графики через скрипты (обычно используется JavaScript). На пример, его можно использовать для отрисовки графиков, делать композиции фото или даже выполнять анимации. Вы можете (и должны) дать альтернативное содержание внури блока &lt;canvas&gt;. Этот контент будет рендерится в обоих браузерах, в старых которые не поддерживают canvas и в браузерах с отключённым JavaScript."><code>&lt;canvas&gt;</code></a>), поэтому <code>miterLimit</code> может устанавливаться независимо от текущей шкалы дисплея или любых аффинных преобразований путей: она влияет только на эффективно визуализированную форму ребер линии.</p>

<p>Точнее, предел митры является максимально допустимым отношением длины расширения (в холсте HTML он измеряется между внешним углом соединенных краев линии и общей конечной точкой соединительных сегментов, указанными на пути), до половины ширины линии. Его можно равнозначно определить как максимально допустимое отношение расстояния между внутренней и внешней точками перехода краев к общей ширине линии. Затем он равен косекансу с половиной минимального внутреннего угла соединительных сегментов, ниже которого не будет создано ни одного соединения митра, а только скос соединяется:</p>

<ul>
 <li><code>miterLimit</code> = <strong>max</strong> <code>miterLength</code> / <code>lineWidth</code> = 1 / <strong>sin</strong> ( <strong>min</strong> <em>θ</em> / 2 )</li>
 <li>Предел митры по умолчанию, равный 10,0, разделит все митры углов, острее примерно 11 градусов.</li>
 <li>Предел митры, равный √2 ≈ 1.4142136 (rounded up) сгладит миты для всех острых углов, поддерживая митры только для тупых или прямых углов.</li>
 <li>Предел митры, равный 1,0, действителен, но отключит все миты.</li>
 <li>Значения ниже 1.0 являются недопустимыми для предела митры.</li>
</ul>

<p>Вот небольшая демонстрация, в которой вы можете динамически установить <code>miterLimit</code> и посмотреть, как это влияет на фигуры на холсте. Синие линии показывают, где начальная и конечная точки для каждой из линий в шаблоне зигзага.</p>

<p>Если вы укажете в этой демонстрации значение <code>miterLimit</code> ниже 4.2, ни один из видимых углов не присоединится к расширению митры, но только с небольшим скосом рядом с синими линиями; с отметкой <code>miterLimit</code> выше 10, большинство углов в этой демонстрации должны соединяться с митрой, удаленной от синих линий, высота которой уменьшается между углами слева направо, потому что они соединяются с растущими углами; с промежуточными значениями углы с левой стороны будут соединяться только с скосом рядом с синими линиями, а углы с правой стороны с удлинителем митры (также с уменьшающейся высотой).</p>

<pre class="brush: js;highlight[18] notranslate">function draw() {
  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);

  // Clear canvas
  ctx.clearRect(0,0,150,150);

  // Draw guides
  ctx.strokeStyle = &apos;#09f&apos;;
  ctx.lineWidth   = 2;
  ctx.strokeRect(-5,50,160,50);

  // Set line styles
  ctx.strokeStyle = &apos;#000&apos;;
  ctx.lineWidth = 10;

  // check input
  if (document.getElementById(&apos;miterLimit&apos;).value.match(/\d+(\.\d+)?/)) {
    ctx.miterLimit = parseFloat(document.getElementById(&apos;miterLimit&apos;).value);
  } else {
    alert(&apos;Value must be a positive number&apos;);
  }

  // Draw lines
  ctx.beginPath();
  ctx.moveTo(0,100);
  for (i=0;i&lt;24;i++){
    var dy = i%2==0 ? 25 : -25 ;
    ctx.lineTo(Math.pow(i,1.5)*2,75+dy);
  }
  ctx.stroke();
  return false;
}
</pre>

<div class="hidden">
<pre class="brush: html notranslate">&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;&lt;/td&gt;
    &lt;td&gt;Change the &lt;code&gt;miterLimit&lt;/code&gt; by entering a new value below and clicking the redraw button.&lt;br&gt;&lt;br&gt;
      &lt;form onsubmit=&quot;return draw();&quot;&gt;
        &lt;label&gt;Miter limit&lt;/label&gt;
        &lt;input type=&quot;text&quot; size=&quot;3&quot; id=&quot;miterLimit&quot;/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Redraw&quot;/&gt;
      &lt;/form&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</pre>

<pre class="brush: js notranslate">document.getElementById(&apos;miterLimit&apos;).value = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;).miterLimit;
draw();</pre>
</div>

<table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img alt class="internal" src="https://mdn.mozillademos.org/files/240/Canvas_miterlimit.png"></td><td><iframe class="live-sample-frame sample-code-frame" frameborder="0" height="180" id="frame_Демонстрация_свойства_miterLimit" src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D1%82%D0%B8%D0%BB%D0%B5%D0%B9_%D0%B8_%D1%86%D0%B2%D0%B5%D1%82%D0%BE%D0%B2$samples/%D0%94%D0%B5%D0%BC%D0%BE%D0%BD%D1%81%D1%82%D1%80%D0%B0%D1%86%D0%B8%D1%8F_%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0_miterLimit?revision=1629489" width="400"></iframe></td></tr></tbody></table>

<h3 id="Использование_штрихов">Использование штрихов</h3>

<p>Метод setLineDash и свойство lineDashOffset задают шаблон штрихов для линий. Метод setLineDash принимает список чисел, который определяет расстояния для попеременного рисования линии и разрыва, а свойство lineDashOffset устанавливает смещение, с которого начинается шаблон.</p>

<p>В этом примере мы создаем эффект походных муравьев. Это техника анимации, часто встречающаяся в инструментах выбора программ компьютерной графики. Это помогает пользователю отличить границу выделения от фона изображения, анимируя границу. В следующей части этого руководства вы узнаете, как сделать эту и другие основные анимации.</p>

<div class="hidden">
<pre class="brush: html notranslate">&lt;canvas id=&quot;canvas&quot; width=&quot;110&quot; height=&quot;110&quot;&gt;&lt;/canvas&gt;</pre>
</div>

<pre class="brush: js;highlight[6] notranslate">var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);
var offset = 0;

function draw() {
  ctx.clearRect(0,0, canvas.width, canvas.height);
  ctx.setLineDash([4, 2]);
  ctx.lineDashOffset = -offset;
  ctx.strokeRect(10,10, 100, 100);
}

function march() {
  offset++;
  if (offset &gt; 16) {
    offset = 0;
  }
  draw();
  setTimeout(march, 20);
}

march();</pre>

<table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img alt class="internal" src="https://mdn.mozillademos.org/files/9853/marching-ants.png"></td><td><iframe class="live-sample-frame sample-code-frame" frameborder="0" height="120" id="frame_Используемый штрих" src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D1%82%D0%B8%D0%BB%D0%B5%D0%B9_%D0%B8_%D1%86%D0%B2%D0%B5%D1%82%D0%BE%D0%B2$samples/%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D0%BC%D1%8B%D0%B9%20%D1%88%D1%82%D1%80%D0%B8%D1%85?revision=1629489" width="120"></iframe></td></tr></tbody></table>

<h2 id="Градиенты">Градиенты</h2>

<p>Just like any normal drawing program, we can fill and stroke shapes using linear and radial gradients. We create a <a href="/ru/docs/Web/API/CanvasGradient"><code>CanvasGradient</code></a> object by using one of the following methods. We can then assign this object to the <code>fillStyle</code> or <code>strokeStyle</code> properties.</p>

<dl>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/createLinearGradient"><code>createLinearGradient(x1, y1, x2, y2)</code></a></dt>
 <dd>Creates a linear gradient object with a starting point of (<code>x1</code>, <code>y1</code>) and an end point of (<code>x2</code>, <code>y2</code>).</dd>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/createRadialGradient"><code>createRadialGradient(x1, y1, r1, x2, y2, r2)</code></a></dt>
 <dd>Creates a radial gradient. The parameters represent two circles, one with its center at (<code>x1</code>, <code>y1</code>) and a radius of <code>r1</code>, and the other with its center at (<code>x2</code>, <code>y2</code>) with a radius of <code>r2</code>.</dd>
</dl>

<p>For example:</p>

<pre class="brush: js notranslate">var lineargradient = ctx.createLinearGradient(0, 0, 150, 150);
var radialgradient = ctx.createRadialGradient(75, 75, 0, 75, 75, 100);
</pre>

<p>Once we&apos;ve created a <code>CanvasGradient</code> object we can assign colors to it by using the <code>addColorStop()</code> method.</p>

<dl>
 <dt><a href="/ru/docs/Web/API/CanvasGradient/addColorStop"><code>gradient.addColorStop(position, color)</code></a></dt>
 <dd>Creates a new color stop on the <code>gradient</code> object. The <code>position</code> is a number between 0.0 and 1.0 and defines the relative position of the color in the gradient, and the <code>color</code> argument must be a string representing a CSS <a href="/ru/docs/Web/CSS/color_value" title="Тип &lt;color&gt; CSS data type предоставляет цвте в цветовом спектре sRGB. В  &lt;color&gt; может включять значения прозрачности Альфа-канала (alpha-channel), уыказывающие, как цвет сочетаеться с его фоном."><code>&lt;color&gt;</code></a>, indicating the color the gradient should reach at that offset into the transition.</dd>
</dl>

<p>You can add as many color stops to a gradient as you need. Below is a very simple linear gradient from white to black.</p>

<pre class="brush: js notranslate">var lineargradient = ctx.createLinearGradient(0,0,150,150);
lineargradient.addColorStop(0, &apos;white&apos;);
lineargradient.addColorStop(1, &apos;black&apos;);
</pre>

<h3 id="Пример_createLinearGradient">Пример <code>createLinearGradient</code></h3>

<p>In this example, we&apos;ll create two different gradients. As you can see here, both the <code>strokeStyle</code> and <code>fillStyle</code> properties can accept a <code>canvasGradient</code> object as valid input.</p>

<pre class="brush: js;highlight[5,11] notranslate">function draw() {
  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);

  // Create gradients
  var lingrad = ctx.createLinearGradient(0,0,0,150);
  lingrad.addColorStop(0, &apos;#00ABEB&apos;);
  lingrad.addColorStop(0.5, &apos;#fff&apos;);
  lingrad.addColorStop(0.5, &apos;#26C000&apos;);
  lingrad.addColorStop(1, &apos;#fff&apos;);

  var lingrad2 = ctx.createLinearGradient(0,50,0,95);
  lingrad2.addColorStop(0.5, &apos;#000&apos;);
  lingrad2.addColorStop(1, &apos;rgba(0,0,0,0)&apos;);

  // assign gradients to fill and stroke styles
  ctx.fillStyle = lingrad;
  ctx.strokeStyle = lingrad2;

  // draw shapes
  ctx.fillRect(10,10,130,130);
  ctx.strokeRect(50,50,50,50);

}
</pre>

<div class="hidden">
<pre class="brush: html notranslate">&lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;</pre>

<pre class="brush: js notranslate">draw();</pre>
</div>

<p>The first is a background gradient. As you can see, we assigned two colors at the same position. You do this to make very sharp color transitions—in this case from white to green. Normally, it doesn&apos;t matter in what order you define the color stops, but in this special case, it does significantly. If you keep the assignments in the order you want them to appear, this won&apos;t be a problem.</p>

<p>In the second gradient, we didn&apos;t assign the starting color (at position 0.0) since it wasn&apos;t strictly necessary, because it will automatically assume the color of the next color stop. Therefore, assigning the black color at position 0.5 automatically makes the gradient, from the start to this stop, black.</p>

<table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img alt class="internal" src="https://mdn.mozillademos.org/files/235/Canvas_lineargradient.png"></td><td><iframe class="live-sample-frame sample-code-frame" frameborder="0" height="180" id="frame_Пример_createLinearGradient" src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D1%82%D0%B8%D0%BB%D0%B5%D0%B9_%D0%B8_%D1%86%D0%B2%D0%B5%D1%82%D0%BE%D0%B2$samples/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_createLinearGradient?revision=1629489" width="180"></iframe></td></tr></tbody></table>

<h3 id="Пример_createRadialGradient">Пример <code>createRadialGradient</code></h3>

<p>In this example, we&apos;ll define four different radial gradients. Because we have control over the start and closing points of the gradient, we can achieve more complex effects than we would normally have in the &quot;classic&quot; radial gradients we see in, for instance, Photoshop (that is, a gradient with a single center point where the gradient expands outward in a circular shape).</p>

<pre class="brush: js;highlight[5,10,15,20] notranslate">function draw() {
  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);

  // Create gradients
  var radgrad = ctx.createRadialGradient(45,45,10,52,50,30);
  radgrad.addColorStop(0, &apos;#A7D30C&apos;);
  radgrad.addColorStop(0.9, &apos;#019F62&apos;);
  radgrad.addColorStop(1, &apos;rgba(1,159,98,0)&apos;);

  var radgrad2 = ctx.createRadialGradient(105,105,20,112,120,50);
  radgrad2.addColorStop(0, &apos;#FF5F98&apos;);
  radgrad2.addColorStop(0.75, &apos;#FF0188&apos;);
  radgrad2.addColorStop(1, &apos;rgba(255,1,136,0)&apos;);

  var radgrad3 = ctx.createRadialGradient(95,15,15,102,20,40);
  radgrad3.addColorStop(0, &apos;#00C9FF&apos;);
  radgrad3.addColorStop(0.8, &apos;#00B5E2&apos;);
  radgrad3.addColorStop(1, &apos;rgba(0,201,255,0)&apos;);

  var radgrad4 = ctx.createRadialGradient(0,150,50,0,140,90);
  radgrad4.addColorStop(0, &apos;#F4F201&apos;);
  radgrad4.addColorStop(0.8, &apos;#E4C700&apos;);
  radgrad4.addColorStop(1, &apos;rgba(228,199,0,0)&apos;);

  // draw shapes
  ctx.fillStyle = radgrad4;
  ctx.fillRect(0,0,150,150);
  ctx.fillStyle = radgrad3;
  ctx.fillRect(0,0,150,150);
  ctx.fillStyle = radgrad2;
  ctx.fillRect(0,0,150,150);
  ctx.fillStyle = radgrad;
  ctx.fillRect(0,0,150,150);
}
</pre>

<div class="hidden">
<pre class="brush: html notranslate">&lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;</pre>

<pre class="brush: js notranslate">draw();</pre>
</div>

<p>In this case, we&apos;ve offset the starting point slightly from the end point to achieve a spherical 3D effect. It&apos;s best to try to avoid letting the inside and outside circles overlap because this results in strange effects which are hard to predict.</p>

<p>The last color stop in each of the four gradients uses a fully transparent color. If you want to have a nice transition from this to the previous color stop, both colors should be equal. This isn&apos;t very obvious from the code because it uses two different CSS color methods as a demonstration, but in the first gradient <code>#019F62 = rgba(1,159,98,1)</code>.</p>

<table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img alt class="internal" src="https://mdn.mozillademos.org/files/244/Canvas_radialgradient.png"></td><td><iframe class="live-sample-frame sample-code-frame" frameborder="0" height="180" id="frame_Пример_createRadialGradient" src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D1%82%D0%B8%D0%BB%D0%B5%D0%B9_%D0%B8_%D1%86%D0%B2%D0%B5%D1%82%D0%BE%D0%B2$samples/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_createRadialGradient?revision=1629489" width="180"></iframe></td></tr></tbody></table>

<h2 id="Шаблоны">Шаблоны</h2>

<p>В одном из предыдущих примеров мы использовали несколько циклов, чтобы создать шаблон из повторяющихся изображений. Однако, есть более простой способ сделать подобное - метод <code>createPattern()</code>.</p>

<dl>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/createPattern"><code>createPattern(image, type)</code></a></dt>
 <dd>Создает и возвращает новый canvas объект - шаблон (pattern). <code>image</code> - <a href="/ru/docs/Web/API/CanvasImageSource"><code>CanvasImageSource</code></a> (то есть <a href="/ru/docs/Web/API/HTMLImageElement"><code>HTMLImageElement</code></a>, другой холст, элемент <a href="/ru/docs/Web/HTML/Element/video" title="Для встраивания видео контента в документ используйте элемент HTML &lt;video&gt;. Видео элемент может содержать один или несколько источников видео. Чтобы указать источник видео, необходимо использовать атрибут src или элемент &lt;source&gt;; браузер сам определит наиболее подходящий источник."><code>&lt;video&gt;</code></a> или подобный  объект. <code>type</code> - строка, указывающая, как использовать <code>image</code>.</dd>
</dl>

<p>Тип указывает, как использовать image для создания шаблона и должен быть одним из следующих значений:</p>

<dl>
 <dt><code>repeat</code></dt>
 <dd>Повторяет изображение в вертикальном и горизонтальном направлениях.</dd>
 <dt><code>repeat-x</code></dt>
 <dd>Повторяет изображение по горизонтали, но не по вертикали.</dd>
 <dt><code>repeat-y</code></dt>
 <dd>Повторяет изображение по вертикали, но не по горизонтали.</dd>
 <dt><code>no-repeat</code></dt>
 <dd>Не повторяет изображение. Используется только один раз.</dd>
</dl>

<p>Мы используем этот метод, чтобы создать <a href="/ru/docs/Web/API/CanvasPattern"><code>CanvasPattern</code></a> объект, который очень похож на методы градиента, рассмотренные ранее. Как только мы создали шаблон, мы можем назначить ему свойства <code>fillStyle</code> или <code>strokeStyle</code>. Например:</p>

<pre class="brush: js notranslate">var img = new Image();
img.src = &apos;someimage.png&apos;;
var ptrn = ctx.createPattern(img,&apos;repeat&apos;);
</pre>

<div class="note notecard">
<p><strong>Примечание:</strong> По аналогии с методом <code>drawImage()</code>, вы должны убедиться, что изображение, которое вы используете, загружено до вызова этого метода. Иначе шаблон может быть отрисован некорректно.</p>
</div>

<h3 id="Пример_createPattern">Пример <code>createPattern</code></h3>

<p>In this last example, we&apos;ll create a pattern to assign to the <code>fillStyle</code> property. The only thing worth noting is the use of the image&apos;s <code>onload</code> handler. This is to make sure the image is loaded before it is assigned to the pattern.</p>

<pre class="brush: js;highlight[10] notranslate">function draw() {
  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);

  // create new image object to use as pattern
  var img = new Image();
  img.src = &apos;https://mdn.mozillademos.org/files/222/Canvas_createpattern.png&apos;;
  img.onload = function(){

    // create pattern
    var ptrn = ctx.createPattern(img,&apos;repeat&apos;);
    ctx.fillStyle = ptrn;
    ctx.fillRect(0,0,150,150);

  }
}
</pre>

<div class="hidden">
<pre class="brush: html notranslate">&lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;</pre>

<pre class="brush: js notranslate">draw();</pre>

<p>The result looks like this:</p>
</div>

<table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img alt class="internal" src="https://mdn.mozillademos.org/files/222/Canvas_createpattern.png"></td><td><iframe class="live-sample-frame sample-code-frame" frameborder="0" height="180" id="frame_Пример_createPattern" src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D1%82%D0%B8%D0%BB%D0%B5%D0%B9_%D0%B8_%D1%86%D0%B2%D0%B5%D1%82%D0%BE%D0%B2$samples/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_createPattern?revision=1629489" width="180"></iframe></td></tr></tbody></table>

<h2 id="Тени">Тени</h2>

<p>Using shadows involves just four properties:</p>

<dl>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/shadowOffsetX"><code>shadowOffsetX = float</code></a></dt>
 <dd>Indicates the horizontal distance the shadow should extend from the object. This value isn&apos;t affected by the transformation matrix. The default is 0.</dd>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/shadowOffsetY"><code>shadowOffsetY = float</code></a></dt>
 <dd>Indicates the vertical distance the shadow should extend from the object. This value isn&apos;t affected by the transformation matrix. The default is 0.</dd>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/shadowBlur"><code>shadowBlur = float</code></a></dt>
 <dd>Indicates the size of the blurring effect; this value doesn&apos;t correspond to a number of pixels and is not affected by the current transformation matrix. The default value is 0.</dd>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/shadowColor"><code>shadowColor = color</code></a></dt>
 <dd>A standard CSS color value indicating the color of the shadow effect; by default, it is fully-transparent black.</dd>
</dl>

<p>The properties <code>shadowOffsetX</code> and <code>shadowOffsetY</code> indicate how far the shadow should extend from the object in the X and Y directions; these values aren&apos;t affected by the current transformation matrix. Use negative values to cause the shadow to extend up or to the left, and positive values to cause the shadow to extend down or to the right. These are both 0 by default.</p>

<p>The <code>shadowBlur</code> property indicates the size of the blurring effect; this value doesn&apos;t correspond to a number of pixels and is not affected by the current transformation matrix. The default value is 0.</p>

<p>The <code>shadowColor</code> property is a standard CSS color value indicating the color of the shadow effect; by default, it is fully-transparent black.</p>

<div class="note notecard">
<p><strong>Note:</strong> Shadows are only drawn for <code>source-over</code> <a href="/en-US/docs/Web/API/Canvas_API/Tutorial/Compositing" title="Web/Guide/HTML/Canvas_tutorial/Compositing">compositing operations</a>.</p>
</div>

<h3 id="Пример_текста_с_тенью">Пример текста с тенью</h3>

<p>This example draws a text string with a shadowing effect.</p>

<pre class="brush: js;highlight[4,5,6,7] notranslate">function draw() {
  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);

  ctx.shadowOffsetX = 2;
  ctx.shadowOffsetY = 2;
  ctx.shadowBlur = 2;
  ctx.shadowColor = &quot;rgba(0, 0, 0, 0.5)&quot;;

  ctx.font = &quot;20px Times New Roman&quot;;
  ctx.fillStyle = &quot;Black&quot;;
  ctx.fillText(&quot;Sample String&quot;, 5, 30);
}
</pre>

<div class="hidden">
<pre class="brush: html notranslate">&lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;80&quot;&gt;&lt;/canvas&gt;</pre>

<pre class="brush: js notranslate">draw();</pre>
</div>

<table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img alt class="internal" src="https://mdn.mozillademos.org/files/2505/shadowed-string.png"></td><td><iframe class="live-sample-frame sample-code-frame" frameborder="0" height="100" id="frame_Пример_текста_с_тенью" src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D1%82%D0%B8%D0%BB%D0%B5%D0%B9_%D0%B8_%D1%86%D0%B2%D0%B5%D1%82%D0%BE%D0%B2$samples/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B0_%D1%81_%D1%82%D0%B5%D0%BD%D1%8C%D1%8E?revision=1629489" width="180"></iframe></td></tr></tbody></table>

<p>We will look at the <code>font</code> property and <code>fillText</code> method in the next chapter about <a href="/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_text">drawing text</a>.</p>

<h2 id="Canvas_fill_rules">Canvas fill rules</h2>

<p>When using <code>fill</code> (or <a href="/ru/docs/Web/API/CanvasRenderingContext2D/clip"><code>clip</code></a> and <a href="/ru/docs/Web/API/CanvasRenderingContext2D/isPointInPath"><code>isPointinPath</code></a>) you can optionally provide a fill rule algorithm by which to determine if a point is inside or outside a path and thus if it gets filled or not. This is useful when a path intersetcs itself or is nested.<br>
 <br>
 Two values are possible:</p>

<ul>
 <li><code><strong>&quot;nonzero</strong></code>&quot;: The <a class="external external-icon" href="http://en.wikipedia.org/wiki/Nonzero-rule">non-zero winding rule</a>, which is the default rule.</li>
 <li><code><strong>&quot;evenodd&quot;</strong></code>: The <a class="external external-icon" href="http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule">even-odd winding rule</a>.</li>
</ul>

<p>In this example we are using the <code>evenodd</code> rule.</p>

<pre class="brush: js;highlight[6] notranslate">function draw() {
  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);
  ctx.beginPath();
  ctx.arc(50, 50, 30, 0, Math.PI*2, true);
  ctx.arc(50, 50, 15, 0, Math.PI*2, true);
  ctx.fill(&quot;evenodd&quot;);
}</pre>

<div class="hidden">
<pre class="brush: html notranslate">&lt;canvas id=&quot;canvas&quot; width=&quot;100&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;</pre>

<pre class="brush: js notranslate">draw();</pre>
</div>

<table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img alt class="internal" src="https://mdn.mozillademos.org/files/9855/fill-rule.png"></td><td><iframe class="live-sample-frame sample-code-frame" frameborder="0" height="110" id="frame_Canvas_fill_rules" src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D1%82%D0%B8%D0%BB%D0%B5%D0%B9_%D0%B8_%D1%86%D0%B2%D0%B5%D1%82%D0%BE%D0%B2$samples/Canvas_fill_rules?revision=1629489" width="110"></iframe></td></tr></tbody></table>

<div class="prevnext" style="text-align: right;">
    <p><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes" style="float: left;" class="button">« Предыдущая статья</a><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Drawing_text" class="button">Следующая статья  »</a></p>
</div>
