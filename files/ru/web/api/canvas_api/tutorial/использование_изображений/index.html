---
title: Использование изображений
slug: Web/API/Canvas_API/Tutorial/Использование_изображений
tags:
  - Графика
translation_of: Web/API/Canvas_API/Tutorial/Using_images
---
<div><section id="Quick_Links">
 <ol>
  <li><a href="/ru/docs/Web/API/Canvas_API"><strong>Canvas API</strong></a></li>
  <li class="toggle">
    <details open>
      <summary>Руководство по Canvas</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Basic_usage">Базовое использование</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes">Рисование фигур</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors">Применение стилей и цветов</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Drawing_text">Рисование текста</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Using_images">Использование изображений</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Transformations">Трансформации</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Compositing">Композиция и обрезка</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Basic_animations">Простые анимации</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Advanced_animations">Расширенные анимации</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas">Манипуляция пикселями</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Hit_regions_and_accessibility">Достижение областей и доступность</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas">Оптимизация canvas</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Finale">Заключение</a></li>
        </ol>
    </details>
  </li>
  <li class="toggle">
    <details open>
      <summary>Примеры</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/Canvas_API/A_basic_ray-caster">Простой излучатель лучей</a></li>
        <li><a href="/ru/Add-ons/Code_snippets/Canvas">Спиппеты кода Canvas</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Manipulating_video_using_canvas">Манипяция видео с помощью canvas</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details open>
      <summary>Интерфейсы</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/HTMLCanvasElement"><code>HTMLCanvasElement</code></a></li>
        <li><a href="/ru/docs/Web/API/CanvasRenderingContext2D"><code>CanvasRenderingContext2D</code></a></li>
        <li><a href="/ru/docs/Web/API/CanvasGradient"><code>CanvasGradient</code></a></li>
        <li><a href="/ru/docs/Web/API/CanvasPattern"><code>CanvasPattern</code></a></li>
        <li><a href="/ru/docs/Web/API/ImageBitmap"><code>ImageBitmap</code></a></li>
        <li><a href="/ru/docs/Web/API/ImageData"><code>ImageData</code></a></li>
        <li><a href="/ru/docs/Web/API/TextMetrics"><code>TextMetrics</code></a></li>
        <li><span class="sidebar-icon"><span title="Это экспериментальное API, которое не должно использоваться в рабочем коде."><i class="icon-beaker"> </i></span></span> <a href="/ru/docs/Web/API/Path2D"><code>Path2D</code></a></li>
      </ol>
    </details>
  </li>
  <li><strong><a href="/ru/docs/MDN">Документация:</a></strong></li>
  <li class="toggle">
    <details>
      <summary>Полезные списки</summary>
      <ol>
        <li><a href="/ru/docs/tag/Canvas">Страницы отмеченные &quot;Canvas&quot;</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details>
      <summary>Внести свой вклад</summary>
      <ol>
        <li><a href="/ru/docs/MDN/Doc_status/API/Canvas">Статус документации по Canvas</a></li>
        <li><a href="/ru/docs/MDN">Проект MDN</a></li>
      </ol>
    </details>
  </li>
 </ol>
</section> <div style="text-align: right;" class="prevnext">
    <p><a style="float: left;" href="/ru/docs/Web/API/Canvas_API/Tutorial/Drawing_text" class="button">« Предыдущая статья</a><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Трансформации" class="button">Следующая статья  »</a></p>
</div></div>

<div class="summary">
<p>До сих пор мы создавали наши собственные фигуры и применяли стили к ним. Одна из самых впечатляющих функций <a href="/ru/docs/Web/HTML/Element/canvas" title="HTML &lt;canvas&gt; Элемент может быть использован для отрисовки графики через скрипты (обычно используется JavaScript). На пример, его можно использовать для отрисовки графиков, делать композиции фото или даже выполнять анимации. Вы можете (и должны) дать альтернативное содержание внури блока &lt;canvas&gt;. Этот контент будет рендерится в обоих браузерах, в старых которые не поддерживают canvas и в браузерах с отключённым JavaScript."><code>&lt;canvas&gt;</code></a> это возможность использования изображений. Они могут быть использованы для динамического композитинга фото или как фоны графиков, для спрайтов в играх, и так далее. Внешние изображения могут быть использованы в любых поддерживаемых браузером форматах, таких как PNG, GIF, или JPEG. Вы можете даже использовать изображение, произведенное другими canvas элементами на той же странице как источник!</p>
</div>

<p>Импортирование изображений в canvas в основном состоит из 2 этапов:</p>

<ol>
 <li>Дав ссылку на <a href="/ru/docs/Web/API/HTMLImageElement" title="Интерфейс HTMLImageElement  предоставляет специальные свойства и методы  (расширяя обычный интерфейс HTMLElement  ) для управления вёрсткой и отображением элемента &lt;img&gt;."><code>HTMLImageElement</code></a> объект или для другого canvas элемента как источник. Также можно использовать изображение дав ссылку на URL.</li>
 <li>Для рисования изображения на canvas используется функция <code>drawImage()</code>.</li>
</ol>

<p>Давайте посмотрим как это сделать.</p>

<h2 id="Использование_изображений_для_рисования">Использование изображений для рисования</h2>

<p>Canvas API может использовать все перечисленные далее типы данных как источник изображения:</p>

<dl>
 <dt><a href="/ru/docs/Web/API/HTMLImageElement" title="Интерфейс HTMLImageElement  предоставляет специальные свойства и методы  (расширяя обычный интерфейс HTMLElement  ) для управления вёрсткой и отображением элемента &lt;img&gt;."><code>HTMLImageElement</code></a></dt>
 <dd>Эти изображения созданы, используя конструктор <code>Image()</code>, также как все<a href="/ru/docs/Web/HTML/Element/img" title="&lt;img&gt; — элемент HTML, предназначенный для описания изображений."><code>&lt;img&gt;</code></a> элементы.</dd>
 <dt><a href="/ru/docs/Web/API/HTMLVideoElement" title="HTMLVideoElement интерфейс предоставляет специальные свойства и методы для манипулирования видео объектов. Он также наследует свойства и методы HTMLMediaElement и HTMLElement."><code>HTMLVideoElement</code></a></dt>
 <dd>Используя HTML <a href="/ru/docs/Web/HTML/Element/video" title="Для встраивания видео контента в документ используйте элемент HTML &lt;video&gt;. Видео элемент может содержать один или несколько источников видео. Чтобы указать источник видео, необходимо использовать атрибут src или элемент &lt;source&gt;; браузер сам определит наиболее подходящий источник."><code>&lt;video&gt;</code></a> элемент как источник изображения захватывает текущий кадр из видео и использует его как изображение.</dd>
 <dt><a href="/ru/docs/Web/API/HTMLCanvasElement" title="Интерфейс HTMLCanvasElement предоставляет свойства и методы для управления расположением и представлением элеметов canvas. Он также наследует свойства и методы интерфейса HTMLElement."><code>HTMLCanvasElement</code></a></dt>
 <dd>Вы можете использовать другой <a href="/ru/docs/Web/HTML/Element/canvas" title="HTML &lt;canvas&gt; Элемент может быть использован для отрисовки графики через скрипты (обычно используется JavaScript). На пример, его можно использовать для отрисовки графиков, делать композиции фото или даже выполнять анимации. Вы можете (и должны) дать альтернативное содержание внури блока &lt;canvas&gt;. Этот контент будет рендерится в обоих браузерах, в старых которые не поддерживают canvas и в браузерах с отключённым JavaScript."><code>&lt;canvas&gt;</code></a> элемент как источник изображения.</dd>
</dl>

<p>Эти источники совместно именуемые по типу <a href="/ru/docs/Web/API/CanvasImageSource" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!"><code>CanvasImageSource</code></a>.</p>

<p>Есть несколько способов, чтобы получить изображения для использования на холсте.</p>

<h3 id="Использование_изображений_из_той_же_страницы">Использование изображений из той же страницы</h3>

<p>Мы можем получить ссылку на изображение, на той же странице, на canvas с используя  один из способов: </p>

<ul>
 <li> <a href="/ru/docs/Web/API/Document/images"><code>document.images</code></a> коллекция</li>
 <li>The <a href="/ru/docs/Web/API/Document/getElementsByTagName"><code>document.getElementsByTagName()</code></a> метод</li>
 <li>Если вы знаете id конкретного изображения, который вы хотите использовать, вы можете использовать <a href="/ru/docs/Web/API/Document/getElementById_"><code>document.getElementById ()</code></a>, чтобы получить это конкретное изображение</li>
</ul>

<h3 id="Использование_изображений_из_других_доменов">Использование изображений из других доменов</h3>

<p>Использование <code><a href="/ru/docs/Web/HTML/Element/img#attr-crossorigin">crossorigin</a></code> атрибута <a href="/ru/docs/Web/HTML/Element/img" title="&lt;img&gt; — элемент HTML, предназначенный для описания изображений."><code>&lt;img&gt;</code></a> элемент (отображается  <a href="/ru/docs/Web/API/HTMLImageElement/crossOrigin" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!"><code>HTMLImageElement.crossOrigin</code></a> свойства), вы можете запросить разрешение на загрузку другого домена для использования в <code>drawImage()</code>. Если хостинг домен разрешает доступ к междоменному изображению, то изображение может быть использовано в вашем canvas без  without tainting it;иначе он может испортить ваш canvas.</p>

<h3 id="Использование_других_canvas_элементов">Использование других canvas элементов</h3>

<p>Как и с обычными изображениями, мы можем получить доступ к другим canvas элементам используя либо <a href="/ru/docs/Web/API/Document/getElementsByTagName" title="Возвращает HTMLCollection элементов с указанным именем тега."><code>document.getElementsByTagName()</code></a> либо <a href="/ru/docs/Web/API/Document/getElementById" title="Возвращает ссылку на элемент по его идентификатору (ID); идентификатор является строкой, которая может быть использована для идентификации элемента; она может быть определена при помощи атрибута id в HTML или из скрипта."><code>document.getElementById()</code></a> метод. Проверьте, что в canvas источнике уже что-то нарисовано, прежде чем использовать его в целевом изображении canvas.</p>

<p>Одним из удобных способов было бы использование второго элемента canvas  в качестве миниатюры другого большего изображения canvas.</p>

<h3 id="Создание_изображений_с_нуля">Создание изображений с нуля</h3>

<p>Другой способ это создать новые <a href="/ru/docs/Web/API/HTMLImageElement" title="Интерфейс HTMLImageElement  предоставляет специальные свойства и методы  (расширяя обычный интерфейс HTMLElement  ) для управления вёрсткой и отображением элемента &lt;img&gt;."><code>HTMLImageElement</code></a> объекты в нашем скрипте.  Чтобы это сделать, вы можете использовать удобный <code>Image()</code> конструктор:</p>

<pre class="brush: js">var img = new Image();   // Создает новый элемент изображения
img.src = &apos;myImage.png&apos;; // Устанавливает путь
</pre>

<p>Когда этот скрипт выполнится, изображение начнет загружаться.</p>

<p>Если вы попытаетесь вызвать функцию <code>drawImage()</code> перед тем как изображение загрузится, то скрипт ничего не сделает (или, в старых браузерах, может даже выдать исключение). Поэтому вам необходимо использовать событие load, чтобы вы не пытались сделать это прежде, чем изображение загрузится:</p>

<pre class="brush: js">var img = new Image();   // Создает новое изображение
img.addEventListener(&quot;load&quot;, function() {
  // здесь выполняет drawImage функцию
}, false);
img.src = &apos;myImage.png&apos;; // Устанавливает источник файла
</pre>

<p>Если вы используете только одно стороннее изображение, то этот метод может быть хорошим примером, но если нужно следить за несколькими изображениями, то необходимо придумать что-то более умное. Хотя поиски тактики проверки загрузки изображений выходят за пределы этого обучающего курса,  вы должны об этом помнить.</p>

<h3 id="Вложение_изображения_с_помощью_данных_URL">Вложение изображения с помощью данных: URL</h3>

<p>Другой возможный способ включить изображение это через <a href="/en-US/docs/Web/HTTP/data_URIs" class="external" rel="external" title="http://en.wikipedia.org/wiki/Data:_URL">data: url</a>. Data URLs позволяет вам полностью определить изображение как Base64 кодированную строку символов прямо в ваш код.</p>

<pre class="brush: js">var img = new Image();   // Создает новый элемент img
img.src = &apos;data:image/gif;base64,R0lGODlhCwALAIAAAAAA3pn/ZiH5BAEAAAEALAAAAAALAAsAAAIUhA+hkcuO4lmNVindo7qyrIXiGBYAOw==&apos;;
</pre>

<p>Одним из преимуществ data URLs  это то что полученное изображение доступно сразу без других запросов туда-обратно на сервер. Другое потенциальное преимущество в том, что также можно инкапсулировать всё в одном файле все ваши <a href="/en-US/docs/Web/CSS" title="/en-US/docs/Web/CSS">CSS</a>, <a href="/en-US/docs/Web/JavaScript" title="/en-US/docs/Web/JavaScript">JavaScript</a>, <a href="/en-US/docs/Web/HTML" title="/en-US/docs/Web/HTML">HTML</a>, и изображения, что делает его более портативным в других местах.</p>

<p>Некоторые недостатки этого метода в том что ваше изображение не кешировано, и для изображений с большим размером кодированние url может стать очень долгим процессом.</p>

<h3 id="Использование_кадров_из_видео">Использование кадров из видео</h3>

<p>Вы также можете использовать кадры из видео представленных <a href="/ru/docs/Web/HTML/Element/video" title="Для встраивания видео контента в документ используйте элемент HTML &lt;video&gt;. Видео элемент может содержать один или несколько источников видео. Чтобы указать источник видео, необходимо использовать атрибут src или элемент &lt;source&gt;; браузер сам определит наиболее подходящий источник."><code>&lt;video&gt;</code></a> элементом (даже если видео не видно). Например, если у вас есть  <a href="/ru/docs/Web/HTML/Element/video" title="Для встраивания видео контента в документ используйте элемент HTML &lt;video&gt;. Видео элемент может содержать один или несколько источников видео. Чтобы указать источник видео, необходимо использовать атрибут src или элемент &lt;source&gt;; браузер сам определит наиболее подходящий источник."><code>&lt;video&gt;</code></a> элемент с  ID &quot;myvideo&quot;, вы можете сделать:</p>

<pre class="brush: js">function getMyVideo() {
  var canvas = document.getElementById(&apos;canvas&apos;);
  if (canvas.getContext) {
    var ctx = canvas.getContext(&apos;2d&apos;);

    return document.getElementById(&apos;myvideo&apos;);
  }
}
</pre>

<p>Эта функция вернет <a href="/ru/docs/Web/API/HTMLVideoElement" title="HTMLVideoElement интерфейс предоставляет специальные свойства и методы для манипулирования видео объектов. Он также наследует свойства и методы HTMLMediaElement и HTMLElement."><code>HTMLVideoElement</code></a> объект для этого видео, который, как мы упоминали ранее, является одним из объектов, который можно использовать как <code>CanvasImageSource</code>.</p>

<h2 id="Рисование_изображений">Рисование изображений</h2>

<p>Как только мы получили ссылку на источник объекта изображения, мы можем использовать метод <code>drawImage()</code> для включения его в  canvas. Как мы увидим далее, метод <code>drawImage()</code> перегружен и у него есть несколько вариантов. В базовом варианте он выглядит как:</p>

<dl>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/drawImage" title="CanvasRenderingContext2D.drawImage() метод Canvas 2D API предоставляет разные способы рисования изображения на холсте."><code>drawImage(image, x, y)</code></a></dt>
 <dd>Рисует  изображение, указанное в <code>CanvasImageSource</code> в координатах  (<code>x</code>, <code>y</code>).</dd>
</dl>

<div class="note notecard">
<p>SVG изображения должны указывать ширину и высоту корневого  &lt;svg&gt; элемента.</p>
</div>

<h3 id="Пример_Простой_линейный_график">Пример: Простой линейный график</h3>

<p>В следующем примере, мы будем использовать внешнее изображение в качестве фона для небольшого линейного графика. Использование фонов может сделать ваш скрипт значительно меньше, потому что мы можем избежать необходимости писать код для создания фона. В этом примере мы используем только один образ, поэтому я использую обработчик событий изображения объекта загрузки для выполнения операторов рисования. <code>drawImage()</code> метод определяющий место фона с координатами (0, 0), которые привязаны к верхнему левому углу canvas.</p>

<div class="hidden">
<pre class="brush: html">&lt;html&gt;
 &lt;body onload=&quot;draw();&quot;&gt;
   &lt;canvas id=&quot;canvas&quot; width=&quot;180&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

<pre class="brush: js;highlight[5]">function draw() {
  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);
  var img = new Image();
  img.onload = function(){
    ctx.drawImage(img,0,0);
    ctx.beginPath();
    ctx.moveTo(30,96);
    ctx.lineTo(70,66);
    ctx.lineTo(103,76);
    ctx.lineTo(170,15);
    ctx.stroke();
  };
  img.src = &apos;https://mdn.mozillademos.org/files/5395/backdrop.png&apos;;
}</pre>

<p>Получившийся график выглядит так:</p>

<p></p><table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img src="https://mdn.mozillademos.org/files/206/Canvas_backdrop.png" alt class="internal"></td><td><iframe src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9$samples/Example_A_simple_line_graph?revision=1387814" width="220" height="160" frameborder="0" id="frame_Example_A_simple_line_graph" class="live-sample-frame sample-code-frame"></iframe></td></tr></tbody></table><p></p>

<h2 id="Изменение_размеров">Изменение размеров</h2>

<p>Второй вариант метода <code>drawImage()</code> добавляет два новых параметра и позволяет разместить изображение в  canvas с измененными размерами.</p>

<dl>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/drawImage" title="CanvasRenderingContext2D.drawImage() метод Canvas 2D API предоставляет разные способы рисования изображения на холсте."><code>drawImage(image, x, y, width, height)</code></a></dt>
 <dd>Это добавляет параметр ширины и высоты, которые указывают до какого размера нужно изменить изображение при рисовании его в  canvas.</dd>
</dl>

<h3 id="Пример_Тайлинг_изображения">Пример: Тайлинг изображения</h3>

<p>В этом примере, мы будем использовать изображение в качестве обоев и повторим его в canvas несколько раз. Это может быть сделано просто через цикл, располагая измененные изображения на разных позициях. В коде внизу, первый цикл <code>for</code> проходит по рядам. Второй цикл <code>for</code> проходит по колонкам. Изображение уменьшено на треть от реального размера, которое было  50x38 пикселей.</p>

<div class="note notecard">
<p><strong>Обратите внимание</strong>: Изображения могут стать размытыми, при большом увеличении или зернистыми при значительном уменьшении. Возможно, лучше всего не изменять размеры изображения, если на них есть текст, который должен остаться читаемым. </p>
</div>

<div class="hidden">
<pre class="brush: html">&lt;html&gt;
 &lt;body onload=&quot;draw();&quot;&gt;
   &lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

<pre class="brush: js">function draw() {
  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);
  var img = new Image();
  img.onload = function(){
    for (var i=0;i&lt;4;i++){
      for (var j=0;j&lt;3;j++){
        ctx.drawImage(img,j*50,i*38,50,38);
      }
    }
  };
  img.src = &apos;https://mdn.mozillademos.org/files/5397/rhino.jpg&apos;;
}</pre>

<p>Получившийся рисунок canvas выглядит так:</p>

<p></p><table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img src="https://mdn.mozillademos.org/files/251/Canvas_scale_image.png" alt class="internal"></td><td><iframe src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9$samples/Example_Tiling_an_image?revision=1387814" width="160" height="160" frameborder="0" id="frame_Example_Tiling_an_image" class="live-sample-frame sample-code-frame"></iframe></td></tr></tbody></table><p></p>

<h2 id="Нарезка">Нарезка</h2>

<p>У третьего и последнего варианта метода <code>drawImage()</code> в дополнении к источнику изображения есть еще восемь параметров . Он позволяет нам вырезать кусок из изображения, затем изменить его размер и нарисовать его в canvas.</p>

<dl>
 <dt><a href="/ru/docs/Web/API/CanvasRenderingContext2D/drawImage" title="CanvasRenderingContext2D.drawImage() метод Canvas 2D API предоставляет разные способы рисования изображения на холсте."><code>drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)</code></a></dt>
 <dd>В данном изображении, эта функция берет фрагмент из изображения, в виде прямоугольника, левый верхний угол которого -  (<code>sx</code>, <code>sy</code>), ширина и высота -  <code>sWidth</code> и <code>sHeight</code> и рисует  в  canvas, располагая его в точке  (<code>dx</code>, <code>dy</code>) и изменяя его размер на указанные величины в  <code>dWidth</code> и <code>dHeight</code>.</dd>
</dl>

<p><img src="https://mdn.mozillademos.org/files/225/Canvas_drawimage.jpg" alt style="float: right; height: 290px; width: 300px;" class="internal">Чтобы понять что  делает нарезка, можно посмотреть на изображение справа. Первые четыре параметра определяют местоположение и размер фрагмента исходного изображения.  Последние четыре параметра определяют прямоугольник, в который будет вписано изображение на целевом рисунке  canvas.</p>

<p>Нарезка может быть полезным инструментом, когда вы захотите сделать композицию.  Вы могли бы собрать все элементы в одном файле изображения и использовать этот метод для создания композиции. Например, если вы захотите сделать график, вы могли бы сделать PNG изображение, содержащее все необходимые тексты в одном файле и в зависимости от ваших данных, могли бы достаточно просто изменять график. Другим преимуществом является то, что нет необходимости загружать каждое изображение по отдельности, получив возможность увеличить скорость загрузки.</p>

<h3 id="Пример_Обрамление_изображения">Пример: Обрамление изображения</h3>

<p>В этом примере, мы будем использовать того же носорога, что и в предыдущем примере, но мы отрежем его голову и включим ее в рамку. Изображение рамки это 24-х битный PNG, который включает падающую тень. Так как в 24-х битные PNG изображения включается полный 8-ми битный альфа-канал, в отличие от GIF и 8-битных PNG изображений, он может быть помещен в любой фон, без беспокойства о матовом цвете. </p>

<pre class="brush: html">&lt;html&gt;
 &lt;body onload=&quot;draw();&quot;&gt;
   &lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;
   &lt;div style=&quot;display:none;&quot;&gt;
     &lt;img id=&quot;source&quot; src=&quot;https://mdn.mozillademos.org/files/5397/rhino.jpg&quot; width=&quot;300&quot; height=&quot;227&quot;&gt;
     &lt;img id=&quot;frame&quot; src=&quot;https://mdn.mozillademos.org/files/242/Canvas_picture_frame.png&quot; width=&quot;132&quot; height=&quot;150&quot;&gt;
   &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

<pre class="brush: js">function draw() {
  var canvas = document.getElementById(&apos;canvas&apos;);
  var ctx = canvas.getContext(&apos;2d&apos;);

  // Рисуем фрагмент
  ctx.drawImage(document.getElementById(&apos;source&apos;),
                33, 71, 104, 124, 21, 20, 87, 104);

  // Рисуем рамку
  ctx.drawImage(document.getElementById(&apos;frame&apos;),0,0);
}</pre>

<p>В этот раз мы применили другой способ загрузки изображения. Вместо загрузки методом создания новых <a href="/ru/docs/Web/API/HTMLImageElement" title="Интерфейс HTMLImageElement  предоставляет специальные свойства и методы  (расширяя обычный интерфейс HTMLElement  ) для управления вёрсткой и отображением элемента &lt;img&gt;."><code>HTMLImageElement</code></a> объектов, мы включили их как  <a href="/ru/docs/Web/HTML/Element/img" title="&lt;img&gt; — элемент HTML, предназначенный для описания изображений."><code>&lt;img&gt;</code></a> тэги прямо в наш HTML файл и из них выбрали изображения. Изображения скрыты с помощью  CSS свойства <a href="/ru/docs/Web/CSS/display" title="Свойство display (CSS) определяет тип отображения (display type) элемента, имеющий два основных свойства, определяющих генерацию боксов — внешний тип отображения определяет расположение бокса в схеме потока (flow layout) и внутренний тип отображения определяет расположение дочерних элементов бокса (бокс - это прямоугольная область, являющаяся изображением элемента)."><code>display</code></a>, установленного в &quot;none&quot; для этих изображений.</p>

<p></p><table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img src="https://mdn.mozillademos.org/files/226/Canvas_drawimage2.jpg" alt class="internal"></td><td><iframe src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9$samples/Example_Framing_an_image?revision=1387814" width="160" height="160" frameborder="0" id="frame_Example_Framing_an_image" class="live-sample-frame sample-code-frame"></iframe></td></tr></tbody></table><p></p>

<p>Скрипт, сам по себе, очень простой. Каждому <a href="/ru/docs/Web/HTML/Element/img" title="&lt;img&gt; — элемент HTML, предназначенный для описания изображений."><code>&lt;img&gt;</code></a> присвоен атрибут ID, который  делает удобным их выбор с использованием <a href="/ru/docs/Web/API/Document/getElementById" title="Возвращает ссылку на элемент по его идентификатору (ID); идентификатор является строкой, которая может быть использована для идентификации элемента; она может быть определена при помощи атрибута id в HTML или из скрипта."><code>document.getElementById()</code></a>. Потом мы просто используем функцию  <code>drawImage()</code>, чтобы из первого изображения вырезать фрагмент носорога и вставить его в canvas, затем рисуем рамку сверху, используя второй вызов функции <code>drawImage()</code>.</p>

<h2 id="Пример_галереи_искусства">Пример галереи искусства</h2>

<p>В последнем примере этой главы, мы построим небольшую галлерею искусств. Галерея состоит из таблицы, включающей несколько изображений. Когда страница загрузится,  <a href="/ru/docs/Web/HTML/Element/canvas" title="HTML &lt;canvas&gt; Элемент может быть использован для отрисовки графики через скрипты (обычно используется JavaScript). На пример, его можно использовать для отрисовки графиков, делать композиции фото или даже выполнять анимации. Вы можете (и должны) дать альтернативное содержание внури блока &lt;canvas&gt;. Этот контент будет рендерится в обоих браузерах, в старых которые не поддерживают canvas и в браузерах с отключённым JavaScript."><code>&lt;canvas&gt;</code></a>  элемент вставится в каждое изображение, а вокруг будет нарисована рамка. </p>

<p>В этом случае, у каждого изображения фиксированная ширина и высота, такая же, как и у рамки нарисованной вокруг них.  Вы могли бы усовершенствовать этот скрипт так, чтобы он использовал ширину и высоту изображения, чтобы рамка идеально его окружила.</p>

<p>Код ниже должен говорить сам за себя. Мы проходим циклом через <a href="/ru/docs/Web/API/Document/images" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!"><code>document.images</code></a> контейнер и соответственно добавляем новые элементы  canvas. Возможно следует упомянуть для тех, кто не слишком хорошо знаком с DOM, что для этого используется <a href="/ru/docs/Web/API/Node/insertBefore" title="Метод Node.insertBefore() добавляет элемент в  список дочерних элементов родителя перед указанным элементом."><code>Node.insertBefore</code></a> метод. <code>insertBefore()</code> это метод родительского узла (ячейки таблицы) элемента (изображения) перед которым мы хотим вставить наш новый узел  (элемент canvas).</p>

<pre class="brush: html">&lt;html&gt;
 &lt;body onload=&quot;draw();&quot;&gt;
     &lt;table&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;img src=&quot;https://mdn.mozillademos.org/files/5399/gallery_1.jpg&quot;&gt;&lt;/td&gt;
        &lt;td&gt;&lt;img src=&quot;https://mdn.mozillademos.org/files/5401/gallery_2.jpg&quot;&gt;&lt;/td&gt;
        &lt;td&gt;&lt;img src=&quot;https://mdn.mozillademos.org/files/5403/gallery_3.jpg&quot;&gt;&lt;/td&gt;
        &lt;td&gt;&lt;img src=&quot;https://mdn.mozillademos.org/files/5405/gallery_4.jpg&quot;&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;img src=&quot;https://mdn.mozillademos.org/files/5407/gallery_5.jpg&quot;&gt;&lt;/td&gt;
        &lt;td&gt;&lt;img src=&quot;https://mdn.mozillademos.org/files/5409/gallery_6.jpg&quot;&gt;&lt;/td&gt;
        &lt;td&gt;&lt;img src=&quot;https://mdn.mozillademos.org/files/5411/gallery_7.jpg&quot;&gt;&lt;/td&gt;
        &lt;td&gt;&lt;img src=&quot;https://mdn.mozillademos.org/files/5413/gallery_8.jpg&quot;&gt;&lt;/td&gt;
      &lt;/tr&gt;
     &lt;/table&gt;
     &lt;img id=&quot;frame&quot; src=&quot;https://mdn.mozillademos.org/files/242/Canvas_picture_frame.png&quot; width=&quot;132&quot; height=&quot;150&quot;&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>И сюда какую-нибудь CSS для украшения:</p>

<pre class="brush: css">body {
  background: 0 -100px repeat-x url(https://mdn.mozillademos.org/files/5415/bg_gallery.png) #4F191A;
  margin: 10px;
}

img {
  display: none;
}

table {
  margin: 0 auto;
}

td {
  padding: 15px;
}
</pre>

<p>Связывая все вместе  JavaScript рисует наши изображения в рамках:</p>

<pre class="brush: js">function draw() {

  // Цикл по всем изображениям
  for (var i=0;i&lt;document.images.length;i++){

    // Не добавляет canvas для изображения рамки
    if (document.images[i].getAttribute(&apos;id&apos;)!=&apos;frame&apos;){

      // Создает элемент canvas
      var canvas = document.createElement(&apos;canvas&apos;);
      canvas.setAttribute(&apos;width&apos;,132);
      canvas.setAttribute(&apos;height&apos;,150);

      // Вставляет перед изображением
      document.images[i].parentNode.insertBefore(canvas,document.images[i]);

      var ctx = canvas.getContext(&apos;2d&apos;);

      // Рисует изображение в canvas
      ctx.drawImage(document.images[i],15,20);

      // Добавляет рамку
      ctx.drawImage(document.getElementById(&apos;frame&apos;),0,0);
    }
  }
}</pre>

<p><iframe src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9$samples/Art_gallery_example?revision=1387814" width="725" height="400" frameborder="0" id="frame_Art_gallery_example" class="live-sample-frame sample-code-frame"></iframe></p>

<h2 id="Контроль_изменений_размеров_изображения">Контроль изменений размеров изображения</h2>

<p>Как было отмечено ранее, изменение размеров изображений может привести к размытости или к шуму в процессе преобразования. Вы можете использовать контекст рисования <a href="/ru/docs/Web/API/CanvasRenderingContext2D/imageSmoothingEnabled" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!"><code>imageSmoothingEnabled</code></a> свойства, чтобы контролировать использование сглаживающего алгоритма, когда изменяющиеся изображения в вашем контексте. Обычно это свойство установлено в  <code>true</code>, означая, что изображения будут сглажены во время изменения размеров. Вы можете отключить это свойство так:</p>

<pre class="brush: js">ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;
ctx.msImageSmoothingEnabled = false;
ctx.imageSmoothingEnabled = false;
</pre>

<p></p><div style="text-align: right;" class="prevnext">
    <p><a style="float: left;" href="/ru/docs/Web/API/Canvas_API/Tutorial/Drawing_text" class="button">« Предыдущая статья</a><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Transformations" class="button">Следующая статья  »</a></p>
</div><p></p>
