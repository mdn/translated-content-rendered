---
title: Простые анимации
slug: Web/API/Canvas_API/Tutorial/Basic_animations
tags:
  - HTML
  - HTML5
  - Графика
  - Обучение
  - Средний уровень
  - Холст
translation_of: Web/API/Canvas_API/Tutorial/Basic_animations
original_slug: Web/API/Canvas_API/Tutorial/Основы_анимации
---
<div><section id="Quick_Links">
 <ol>
  <li><a href="/ru/docs/Web/API/Canvas_API"><strong>Canvas API</strong></a></li>
  <li class="toggle">
    <details open>
      <summary>Руководство по Canvas</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Basic_usage">Базовое использование</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes">Рисование фигур</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors">Применение стилей и цветов</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Drawing_text">Рисование текста</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Using_images">Использование изображений</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Transformations">Трансформации</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Compositing">Композиция и обрезка</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Basic_animations">Простые анимации</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Advanced_animations">Расширенные анимации</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas">Манипуляция пикселями</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Hit_regions_and_accessibility">Достижение областей и доступность</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas">Оптимизация canvas</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Finale">Заключение</a></li>
        </ol>
    </details>
  </li>
  <li class="toggle">
    <details open>
      <summary>Примеры</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/Canvas_API/A_basic_ray-caster">Простой излучатель лучей</a></li>
        <li><a href="/ru/Add-ons/Code_snippets/Canvas">Спиппеты кода Canvas</a></li>
        <li><a href="/ru/docs/Web/API/Canvas_API/Manipulating_video_using_canvas">Манипяция видео с помощью canvas</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details open>
      <summary>Интерфейсы</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/HTMLCanvasElement"><code>HTMLCanvasElement</code></a></li>
        <li><a href="/ru/docs/Web/API/CanvasRenderingContext2D"><code>CanvasRenderingContext2D</code></a></li>
        <li><a href="/ru/docs/Web/API/CanvasGradient"><code>CanvasGradient</code></a></li>
        <li><a href="/ru/docs/Web/API/CanvasPattern"><code>CanvasPattern</code></a></li>
        <li><a href="/ru/docs/Web/API/ImageBitmap"><code>ImageBitmap</code></a></li>
        <li><a href="/ru/docs/Web/API/ImageData"><code>ImageData</code></a></li>
        <li><a href="/ru/docs/Web/API/TextMetrics"><code>TextMetrics</code></a></li>
        <li><span class="sidebar-icon"><span title="Это экспериментальное API, которое не должно использоваться в рабочем коде."><i class="icon-beaker"> </i></span></span> <a href="/ru/docs/Web/API/Path2D"><code>Path2D</code></a></li>
      </ol>
    </details>
  </li>
  <li><strong><a href="/ru/docs/MDN">Документация:</a></strong></li>
  <li class="toggle">
    <details>
      <summary>Полезные списки</summary>
      <ol>
        <li><a href="/ru/docs/tag/Canvas">Страницы отмеченные &quot;Canvas&quot;</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details>
      <summary>Внести свой вклад</summary>
      <ol>
        <li><a href="/ru/docs/MDN/Doc_status/API/Canvas">Статус документации по Canvas</a></li>
        <li><a href="/ru/docs/MDN">Проект MDN</a></li>
      </ol>
    </details>
  </li>
 </ol>
</section> <div style="text-align: right;" class="prevnext">
    <p><a style="float: left;" href="/ru/docs/Web/API/Canvas_API/Tutorial/Compositing" class="button">« Предыдущая статья</a><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Advanced_animations" class="button">Следующая статья  »</a></p>
</div></div>

<div class="summary">
<p>Поскольку для управления элементами <a href="/ru/docs/Web/HTML/Element/canvas" title="HTML &lt;canvas&gt; Элемент может быть использован для отрисовки графики через скрипты (обычно используется JavaScript). На пример, его можно использовать для отрисовки графиков, делать композиции фото или даже выполнять анимации. Вы можете (и должны) дать альтернативное содержание внури блока &lt;canvas&gt;. Этот контент будет рендерится в обоих браузерах, в старых которые не поддерживают canvas и в браузерах с отключённым JavaScript."><code>&lt;canvas&gt;</code></a> используется JavaScript, не составляет труда сделать (интерактивные) анимации. В этой главе мы рассмотрим, как делаются некоторые базовые анимации.</p>
</div>

<p>Вероятно, самым большим ограничением является то, что когда фигура нарисована, её уже нельзя двигать. Чтобы изобразить движение нам нужно перерисовать фигуру и всё, что было нарисовано до неё. Перерисовка сложных кадров занимает много времени, и производительность сильно зависит от скорости компьютера, на котором она выполняется.</p>

<h2 id="Basic_animation_steps" name="Basic_animation_steps">Основные шаги анимации</h2>

<p>Ниже перечислены необходимые шаги для того, чтобы нарисовать кадр:</p>

<ol>
 <li><strong>Очистить canvas</strong><br>
  Если фигура, которую вы собираетесь нарисовать, не занимает всю площадь canvas (как фон, например), то всё что было нарисовано ранее необходимо стереть. Проще всего это сделать при помощи метода <a href="/ru/docs/Web/API/CanvasRenderingContext2D/clearRect" title="Метод CanvasRenderingContext2D.clearRect(), предоставляемый Canvas 2D API, устанавливает прозрачный черный цвет для всех пикселей, расположенных внутри прямоугольника, заданного начальной точкой (x, y) и размерами (width, height), таким образом стирая любое ранее нарисованное содержимое."><code>clearRect()</code></a>.</li>
 <li><strong>Сохранить изначальное состояние canvas</strong><br>
  Если вы изменяете любые настройки (такие как стили, трансформации и т.п.), которые затрагивают состояние canvas и вы хотите убедиться, что оригинальное состояние используется каждый раз, когда был отрисован кадр, то вам следует сохранить это оригинальное состояние.</li>
 <li><strong>Нарисовать анимированные фигуры</strong><br>
  Шаг на котором вы собственно отрисовываете кадр.</li>
 <li><strong>Восстановить состояние canvas</strong><br>
  Если вы сохраняли состояние, восстановите его, прежде чем отрисовывать новый кадр.</li>
</ol>

<h2 id="Controlling_an_animation" name="Controlling_an_animation">Управление анимацией</h2>

<p>Фигуры отрисовываются на canvas либо напрямую — при помощи методов canvas, либо с помощью сторонних функций. В нормальной ситуации результат станет виден на canvas после окончания выполнения скрипта. К примеру, цикл for использовать для анимации нельзя. </p>

<p>Это значит, нужен способ выполнения функций отрисовки через интервалы времени. Есть два способа для управления такой анимацией.</p>

<h3 id="Запланированные_обновления">Запланированные обновления</h3>

<p>Первый — это функции <a href="/ru/docs/Web/API/Window/setInterval" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!"><code>window.setInterval()</code></a>, <a href="/ru/docs/Web/API/Window/setTimeout" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!"><code>window.setTimeout()</code></a>, и <a href="/ru/docs/Web/API/Window/requestAnimationFrame" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!"><code>window.requestAnimationFrame()</code></a>, которые могут быть использованы для вызова некоторой функции, через заданный промежуток времени.</p>

<dl>
 <dt><a href="/ru/docs/Web/API/WindowTimers/setInterval" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!"><code>setInterval(function, delay)</code></a></dt>
 <dd>Начинает периодически исполнять функцию <code>function</code> каждые <code>delay</code> миллисекунд.</dd>
 <dt><a href="/ru/docs/Web/API/WindowTimers/setTimeout" title="Вызов функции или выполнение фрагмента кода после указанной задержки."><code>setTimeout(function, delay)</code></a></dt>
 <dd>Запускает выполнение указанной функции <code>function</code> через <code>delay</code> миллисекунд.</dd>
 <dt><a href="/ru/docs/Web/API/Window/requestAnimationFrame" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!"><code>requestAnimationFrame(callback)</code></a></dt>
 <dd>Сообщает браузеру, что вы хотите выполнить анимацию, и запрашивает, чтобы браузер вызвал указанную функцию <code>callback</code> для обновления анимации перед следующей перерисовкой.</dd>
</dl>

<p>Если вы не планируете никакого взаимодействия с пользователем, вы можете использовать функцию <code>setInterval()</code> , которая многократно выполняет, предоставленный ей код. Если же вы планиуете создать игру, в которой контроль анимации осуществляется мышью или клавиатурой, то необходимо использовать  <code>setTimeout()</code>. Установив <a href="/ru/docs/Web/API/EventListener" title="Интерфейс EventListener представляет собой объект, который может обработать событие, отправленное объектом EventTarget."><code>EventListener</code></a>, вы можете перехватываете любые действия пользователя и запустить соответствующие функции анимации.</p>

<div class="note notecard">
<p>В примерах ниже мы будем использовать функцию <a href="/ru/docs/Web/API/Window/requestAnimationFrame" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!"><code>window.requestAnimationFrame()</code></a> для контроля анимации. Функция <code>requestAnimationFrame</code> является более эффективной для создания анимации, так как новая итерация вызывается, когда система готова к отрисовке нового кадра. Количество вызовов в секунду примерно равно 60 и уменьшается, когда вкладка неактивна. Для более подробного изучения цикла анимации, особенно для игр, прочитайте статью <a href="/en-US/docs/Games/Anatomy">Анатомия видеоигр </a>В <a href="/en-US/docs/Games">Зоне разработке игр</a>.</p>
</div>

<h2 id="Анимированная_солнечная_система">Анимированная солнечная система</h2>

<p>В этом примере анимируется небольшая модель солнечной системы.</p>

<pre class="brush: js">var sun = new Image();
var moon = new Image();
var earth = new Image();
function init(){
  sun.src = &apos;https://mdn.mozillademos.org/files/1456/Canvas_sun.png&apos;;
  moon.src = &apos;https://mdn.mozillademos.org/files/1443/Canvas_moon.png&apos;;
  earth.src = &apos;https://mdn.mozillademos.org/files/1429/Canvas_earth.png&apos;;
  window.requestAnimationFrame(draw);
}

function draw() {
  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);

  ctx.globalCompositeOperation = &apos;destination-over&apos;;
  ctx.clearRect(0,0,300,300); // clear canvas

  ctx.fillStyle = &apos;rgba(0,0,0,0.4)&apos;;
  ctx.strokeStyle = &apos;rgba(0,153,255,0.4)&apos;;
  ctx.save();
  ctx.translate(150,150);

  // Earth
  var time = new Date();
  ctx.rotate( ((2*Math.PI)/60)*time.getSeconds() + ((2*Math.PI)/60000)*time.getMilliseconds() );
  ctx.translate(105,0);
  ctx.fillRect(0,-12,50,24); // Shadow
  ctx.drawImage(earth,-12,-12);

  // Moon
  ctx.save();
  ctx.rotate( ((2*Math.PI)/6)*time.getSeconds() + ((2*Math.PI)/6000)*time.getMilliseconds() );
  ctx.translate(0,28.5);
  ctx.drawImage(moon,-3.5,-3.5);
  ctx.restore();

  ctx.restore();

  ctx.beginPath();
  ctx.arc(150,150,105,0,Math.PI*2,false); // Earth orbit
  ctx.stroke();

  ctx.drawImage(sun,0,0,300,300);

  window.requestAnimationFrame(draw);
}

init();
</pre>

<div class="hidden">
<pre class="brush: html">&lt;canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;</pre>
</div>

<p></p><table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img src="https://mdn.mozillademos.org/files/202/Canvas_animation1.png" alt class="internal"></td><td><iframe src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B_%D0%B0%D0%BD%D0%B8%D0%BC%D0%B0%D1%86%D0%B8%D0%B8$samples/An_animated_solar_system?revision=1465884" width="310" height="310" frameborder="0" class="live-sample-frame sample-code-frame" id="frame_An_animated_solar_system"></iframe></td></tr></tbody></table><p></p>

<h2 id="Анимированные_часы">Анимированные часы</h2>

<p>В этом примере создаются анимированные часы, показывающие правильное время.</p>

<pre class="brush: js">function clock(){
  var now = new Date();
  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);
  ctx.save();
  ctx.clearRect(0,0,150,150);
  ctx.translate(75,75);
  ctx.scale(0.4,0.4);
  ctx.rotate(-Math.PI/2);
  ctx.strokeStyle = &quot;black&quot;;
  ctx.fillStyle = &quot;white&quot;;
  ctx.lineWidth = 8;
  ctx.lineCap = &quot;round&quot;;

  // Hour marks
  ctx.save();
  for (var i=0;i&lt;12;i++){
    ctx.beginPath();
    ctx.rotate(Math.PI/6);
    ctx.moveTo(100,0);
    ctx.lineTo(120,0);
    ctx.stroke();
  }
  ctx.restore();

  // Minute marks
  ctx.save();
  ctx.lineWidth = 5;
  for (i=0;i&lt;60;i++){
    if (i%5!=0) {
      ctx.beginPath();
      ctx.moveTo(117,0);
      ctx.lineTo(120,0);
      ctx.stroke();
    }
    ctx.rotate(Math.PI/30);
  }
  ctx.restore();

  var sec = now.getSeconds();
  var min = now.getMinutes();
  var hr  = now.getHours();
  hr = hr&gt;=12 ? hr-12 : hr;

  ctx.fillStyle = &quot;black&quot;;

  // write Hours
  ctx.save();
  ctx.rotate( hr*(Math.PI/6) + (Math.PI/360)*min + (Math.PI/21600)*sec )
  ctx.lineWidth = 14;
  ctx.beginPath();
  ctx.moveTo(-20,0);
  ctx.lineTo(80,0);
  ctx.stroke();
  ctx.restore();

  // write Minutes
  ctx.save();
  ctx.rotate( (Math.PI/30)*min + (Math.PI/1800)*sec )
  ctx.lineWidth = 10;
  ctx.beginPath();
  ctx.moveTo(-28,0);
  ctx.lineTo(112,0);
  ctx.stroke();
  ctx.restore();

  // Write seconds
  ctx.save();
  ctx.rotate(sec * Math.PI/30);
  ctx.strokeStyle = &quot;#D40000&quot;;
  ctx.fillStyle = &quot;#D40000&quot;;
  ctx.lineWidth = 6;
  ctx.beginPath();
  ctx.moveTo(-30,0);
  ctx.lineTo(83,0);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(0,0,10,0,Math.PI*2,true);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(95,0,10,0,Math.PI*2,true);
  ctx.stroke();
  ctx.fillStyle = &quot;rgba(0,0,0,0)&quot;;
  ctx.arc(0,0,3,0,Math.PI*2,true);
  ctx.fill();
  ctx.restore();

  ctx.beginPath();
  ctx.lineWidth = 14;
  ctx.strokeStyle = &apos;#325FA2&apos;;
  ctx.arc(0,0,142,0,Math.PI*2,true);
  ctx.stroke();

  ctx.restore();

  window.requestAnimationFrame(clock);
}

window.requestAnimationFrame(clock);</pre>

<div class="hidden">
<pre class="brush: html">&lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;</pre>
</div>

<p></p><table class="sample-code-table"><thead><tr><th scope="col" style="text-align: center;">Screenshot</th><th scope="col" style="text-align: center;">Live sample</th></tr></thead><tbody><tr><td><img src="https://mdn.mozillademos.org/files/203/Canvas_animation2.png" alt class="internal"></td><td><iframe src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B_%D0%B0%D0%BD%D0%B8%D0%BC%D0%B0%D1%86%D0%B8%D0%B8$samples/An_animated_clock?revision=1465884" width="180" height="180" frameborder="0" class="live-sample-frame sample-code-frame" id="frame_An_animated_clock"></iframe></td></tr></tbody></table><p></p>

<h2 id="Зацикленная_панорама">Зацикленная панорама</h2>

<p>В этом примере панорама прокручивается слева направо. Мы используем <a href="http://commons.wikimedia.org/wiki/File:Capitan_Meadows,_Yosemite_National_Park.jpg" title="http://commons.wikimedia.org/wiki/File:Capitan_Meadows,_Yosemite_National_Park.jpg">фото национального парка Йосемити</a> взятое из Википедии, но вы можете использовать любое изображение, большее элемента canvas.</p>

<pre class="brush: js">var img = new Image();

// User Variables - customize these to change the image being scrolled, its
// direction, and the speed.

img.src = &apos;https://mdn.mozillademos.org/files/4553/Capitan_Meadows,_Yosemite_National_Park.jpg&apos;;
var CanvasXSize = 800;
var CanvasYSize = 200;
var speed = 30; //lower is faster
var scale = 1.05;
var y = -4.5; //vertical offset

// Main program

var dx = 0.75;
var imgW;
var imgH;
var x = 0;
var clearX;
var clearY;
var ctx;

img.onload = function() {
    imgW = img.width*scale;
    imgH = img.height*scale;
    if (imgW &gt; CanvasXSize) { x = CanvasXSize-imgW; } // image larger than canvas
    if (imgW &gt; CanvasXSize) { clearX = imgW; } // image larger than canvas
    else { clearX = CanvasXSize; }
    if (imgH &gt; CanvasYSize) { clearY = imgH; } // image larger than canvas
    else { clearY = CanvasYSize; }
    //Get Canvas Element
    ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);
    //Set Refresh Rate
    return setInterval(draw, speed);
}

function draw() {
    //Clear Canvas
    ctx.clearRect(0,0,clearX,clearY);
    //If image is &lt;= Canvas Size
    if (imgW &lt;= CanvasXSize) {
        //reset, start from beginning
        if (x &gt; (CanvasXSize)) { x = 0; }
        //draw aditional image
        if (x &gt; (CanvasXSize-imgW)) { ctx.drawImage(img,x-CanvasXSize+1,y,imgW,imgH); }
    }
    //If image is &gt; Canvas Size
    else {
        //reset, start from beginning
        if (x &gt; (CanvasXSize)) { x = CanvasXSize-imgW; }
        //draw aditional image
        if (x &gt; (CanvasXSize-imgW)) { ctx.drawImage(img,x-imgW+1,y,imgW,imgH); }
    }
    //draw image
    ctx.drawImage(img,x,y,imgW,imgH);
    //amount to move
    x += dx;
}
</pre>

<p>Заметьте, что ширина и высота должны совпадать  со значениями <code>CanvasXZSize</code> и <code>CanvasYSize</code>.</p>

<pre class="brush: html">&lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;</pre>

<p><iframe src="https://mdn.mozillademos.org/ru/docs/Web/API/Canvas_API/Tutorial/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B_%D0%B0%D0%BD%D0%B8%D0%BC%D0%B0%D1%86%D0%B8%D0%B8$samples/A_looping_panorama?revision=1465884" width="830" height="230" frameborder="0" class="live-sample-frame sample-code-frame" id="frame_A_looping_panorama"></iframe></p>

<h2 id="Other_examples" name="Other_examples">Другие примеры</h2>

<dl>
 <dt><a href="/en-US/docs/Web/API/Canvas_API/A_basic_ray-caster" title="/en-US/docs/Web/Guide/HTML/A_basic_ray-caster">A basic ray-caster</a></dt>
 <dd>Хороший пример того, как сделать управляемую анимацию с клавиатуры.</dd>
 <dt><a href="/en-US/docs/Web/API/Canvas_API/Tutorial/Advanced_animations">Advanced animations</a></dt>
 <dd>Мы рассмотрим некоторые продвинутые методы анимации и физику в следующей главе.</dd>
</dl>

<p></p><div style="text-align: right;" class="prevnext">
    <p><a style="float: left;" href="/ru/docs/Web/API/Canvas_API/Tutorial/Compositing" class="button">« Предыдущая статья</a><a href="/ru/docs/Web/API/Canvas_API/Tutorial/Advanced_animations" class="button">Следующая статья  »</a></p>
</div><p></p>
