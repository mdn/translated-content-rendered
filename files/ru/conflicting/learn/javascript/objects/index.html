---
title: Вступление в Объектно-ориентированный JavaScript
slug: conflicting/Learn/JavaScript/Objects
translation_of: Learn/JavaScript/Objects
translation_of_original: Web/JavaScript/Introduction_to_Object-Oriented_JavaScript
original_slug: Web/JavaScript/Introduction_to_Object-Oriented_JavaScript
---
<p>Объектно-ориентированный до основания, JavaScript предоставляет мощные и гибкие <a class="glossaryLink" href="/ru/docs/Словарь/OOP" title="OOP: OOП (Объектно-Ориентированное Программирование) это подход в программировании, согласно которому, данные инкапсулированы внутри objects, а сам объект существует как составная часть целого.">OOP</a> возможности. Эта статья начинается с введения в объектно-ориентированное программирование, затем рассматривает модель объекта JavaScript и, наконец, демонстрирует концепции объектно-ориентированного программирования в JavaScript.</p>

<h2 id="JavaScript_Review" name="JavaScript_Review">Обзор JavaScript</h2>

<p>Если вы неуверенно владеете такими концепциями JavaScript, как переменные, типы, функции и области видимости, вы можете прочитать об этих темах в <a href="/ru/docs/Web/JavaScript/A_re-introduction_to_JavaScript">Повторное вступление в JavaScript</a>. Вы также можете обратиться к <a href="/ru/docs/Web/JavaScript/Guide">JavaScript Guide</a>.</p>

<h2 id="Object-oriented_programming" name="Object-oriented_programming">Объектно-ориентированное программирование</h2>

<p>Объектно-ориентированное программирование (ООП) — это парадигма программирования, которая использует <a class="glossaryLink" href="/ru/docs/Glossary/абстракции" title="Определение термина «абстракции» ещё не написано; может быть, вы напишете?">абстракции</a>, чтобы создавать модели, основанные на объектах реального мира. ООП использует несколько техник из ранее признанных парадигм, включая <a class="glossaryLink" href="/ru/docs/Glossary/модульность" title="Определение термина «модульность» ещё не написано; может быть, вы напишете?">модульность</a>, <a class="glossaryLink" href="/ru/docs/Glossary/полиморфизм" title="Определение термина «полиморфизм» ещё не написано; может быть, вы напишете?">полиморфизм</a> и <a class="glossaryLink" href="/ru/docs/Glossary/инкапсуляция" title="Определение термина «инкапсуляция» ещё не написано; может быть, вы напишете?">инкапсуляция</a>. На сегодняшний день многие популярные языки программирования (такие как Java, JavaScript, C#, C++, Python, PHP, Ruby и Objective-C) поддерживают ООП.</p>

<p>ООП представляет программное обеспечение как совокупность взаимодействующих объектов, а не набор функций или просто список команд (как в традиционном представлении). В ООП, каждый объект может получать сообщения, обрабатывать данные, и отправлять сообщения другим объектам. Каждый объект может быть представлен как маленькая независимая машина с отдельной ролью или ответственностью.</p>

<p>ООП способствует большей гибкости и поддерживаемости в программировании, и широко распространена в крупномасштабном программном инжиниринге. Так как ООП настоятельно подчеркивает модульность, объектно-ориентированный код проще в разработке и проще для понимания впоследствии. Объектно-ориентированный код способствует более точному анализу, кодированию и пониманию сложных ситуаций и процедур, чем методы программирования с меньшей модульностью.<a href="#cite-1"><sup>1</sup></a></p>

<h2 id="Terminology" name="Terminology">Терминология</h2>

<dl>
 <dt><a class="glossaryLink" href="/ru/docs/Glossary/Пространство_имён" title="Определение термина «Пространство имён» ещё не написано; может быть, вы напишете?">Пространство имён</a></dt>
 <dd>Контейнер, который позволяет разработчикам связать весь функционал под уникальным, специфичным для приложения именем.</dd>
 <dt><a class="glossaryLink" href="/ru/docs/Glossary/Класс" title="Определение термина «Класс» ещё не написано; может быть, вы напишете?">Класс</a></dt>
 <dd>Определяет характеристики объекта. Класс является описанием шаблона свойств и методов объекта.</dd>
 <dt><a class="glossaryLink" href="/ru/docs/Glossary/Объект" title="Определение термина «Объект» ещё не написано; может быть, вы напишете?">Объект</a></dt>
 <dd>Экземпляр класса.</dd>
 <dt><a class="glossaryLink" href="/ru/docs/Glossary/Свойство" title="Определение термина «Свойство» ещё не написано; может быть, вы напишете?">Свойство</a></dt>
 <dd>Характеристика объекта, например, цвет.</dd>
 <dt><a class="glossaryLink" href="/ru/docs/Glossary/Метод" title="Определение термина «Метод» ещё не написано; может быть, вы напишете?">Метод</a></dt>
 <dd>Возможности объекта, такие как ходьба. Это подпрограммы или функции, связанные с классом.</dd>
 <dt><a class="glossaryLink" href="/ru/docs/Glossary/Конструктор" title="Определение термина «Конструктор» ещё не написано; может быть, вы напишете?">Конструктор</a></dt>
 <dd>Метод, вызываемый в момент создания экземпляра объекта. Он, как правило, имеет то же имя, что и класс, содержащий его.</dd>
 <dt><a class="glossaryLink" href="/ru/docs/Glossary/Наследование" title="Определение термина «Наследование» ещё не написано; может быть, вы напишете?">Наследование</a></dt>
 <dd>Класс может наследовать характеристики от другого класса.</dd>
 <dt><a class="glossaryLink" href="/ru/docs/Glossary/Инкапсуляция" title="Определение термина «Инкапсуляция» ещё не написано; может быть, вы напишете?">Инкапсуляция</a></dt>
 <dd>Способ комплектации данных и методов, которые используют данные.</dd>
 <dt><a class="glossaryLink" href="/ru/docs/Glossary/Абстракция" title="Определение термина «Абстракция» ещё не написано; может быть, вы напишете?">Абстракция</a></dt>
 <dd>Совокупность комплексных наследований, методов и свойств объекта должны адекватно отражать модель реальности.</dd>
 <dt><a class="glossaryLink" href="/ru/docs/Glossary/Полиморфизм" title="Определение термина «Полиморфизм» ещё не написано; может быть, вы напишете?">Полиморфизм</a></dt>
 <dd>Поли означает &quot;<em>много</em>&quot;, а морфизм &quot;<em>формы</em>&quot;. Различные классы могут объявить один и тот же метод или свойство.</dd>
</dl>

<p>Для более обширного описания объектно-ориентированного программирования, см <a href="https://ru.wikipedia.org/wiki/Объектно-ориентированное_программирование" title="Объектно-ориентированное_программирование">Объектно-ориентированное_программирование</a> в Wikipedia.</p>

<h2 id="Прототипное_программирование">Прототипное программирование</h2>

<p>Прототипное программирование — это модель ООП которая не использует классы, а вместо этого сначала выполняет поведение класса и затем использует его повторно (эквивалент наследования в языках на базе классов), декорируя (или расширяя) существующие<em> </em>объекты <em>прототипы</em>. (Также называемое бесклассовое, прототипно-ориентированное, или экземплярно-ориентированное программирование.)</p>

<p>Оригинальный (и наиболее каноничный) пример прототипно-ориентированного языка это <a href="https://ru.wikipedia.org/wiki/Self (programming language)" title="Self">Self</a> разработанный Дэвидом Ангаром и Ренделлом Смитом. Однако бесклассовый стиль программирования стал набирать популярность позднее, и был принят для таких языков программирования, как JavaScript, Cecil, NewtonScript, Io, MOO, REBOL, Kevo, Squeak (при использовании фреймворка Viewer для манипуляции компонентами Morphic) и некоторых других.<a href="#cite-1"><sup>1</sup></a></p>

<h2 id="JavaScript_Object_Oriented_Programming" name="JavaScript_Object_Oriented_Programming">Объектно-ориентированное программирование в JavaScript</h2>

<h3 id="Пространство_имён">Пространство имён</h3>

<p>Пространство имён — это контейнер, который позволяет разработчикам собрать функциональность под уникальным именем приложения. <strong>Пространство имён в JavaScript — это объект, содержащий методы, свойства и другие объекты.</strong></p>

<div class="note notecard">
<p>Важно отметить, что на уровне языка в JavaScript нет разницы между пространством имён и любым другим объектом. Это отличает JS от множества других объектно-ориентированных языков и может стать причиной путаницы у начинающих JS программистов.</p>
</div>

<p>Принцип работы пространства имён в JS прост: создать один глобальный объект и все переменные, методы и функции объявлять как свойства этого объекта. Также использование пространств имён снижает вероятность возникновения конфликтов имён в приложении так как каждый объект приложения является свойством глобального объекта.</p>

<p>Давайте создадим глобальный объект MYAPP:</p>

<pre class="brush: js">// Глобальное пространство имён
var MYAPP = MYAPP || {};</pre>

<p>Во фрагменте кода выше мы сначала проверяем определён ли объект MYAPP (в текущем файле или другом файле). Если да, то используем существующий глобальный объект MYAPP, иначе создаём пустой объект MYAPP, в котором мы инкапсулируем все методы, функции, переменные и объекты.</p>

<p>Также мы можем создать подпространство имён (учтите, что сначала нужно объявить глобальный объект):</p>

<pre class="brush: js">// Подпространство имён
MYAPP.event = {};</pre>

<p>Далее следует пример синтаксиса создания пространства имён и добавления переменных, функций и методов:</p>

<pre class="brush: js">// Создаём контейнер MYAPP.commonMethod для общих методов и свойств
MYAPP.commonMethod = {
  regExForName: &quot;&quot;, // определяет регулярное выражение для валидации имени
  regExForPhone: &quot;&quot;, // определяет регулярное выражение для валидации телефона
  validateName: function(name){
    // Сделать что-то с name, вы можете получить доступ к переменной regExForName
    // используя &quot;this.regExForName&quot;
  },

  validatePhoneNo: function(phoneNo){
    // Сделать что-то с номером телефона
  }
}

// Объект вместе с объявлением методов
MYAPP.event = {
    addListener: function(el, type, fn) {
    // код
    },
    removeListener: function(el, type, fn) {
    // код
    },
    getEvent: function(e) {
    // код
    }

    // Можно добавить другие свойства и методы
}

// Синтаксис использования метода addListener:
MYAPP.event.addListener(&quot;yourel&quot;, &quot;type&quot;, callback);</pre>

<h3 id="Core_Objects" name="Core_Objects">Стандартные встроенные объекты</h3>

<p>В JavaScript есть несколько объектов, встроенных в ядро, например <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Math" title="Объект Math является встроенным объектом, хранящим в своих свойствах и методах различные математические константы и функции. Объект Math не является функциональным объектом."><code>Math</code></a>, <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object" title="Конструктор Object создаёт объект-обёртку."><code>Object</code></a>, <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Array" title="Массив (Array) в JavaScript является глобальным объектом, который используется для создания массивов; которые представляют собой высокоуровневые спископодобные объекты."><code>Array</code></a> и <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/String" title="Глобальный объект String является конструктором строк, или, последовательностей символов."><code>String</code></a>. Пример ниже показывает как использовать объект Math, чтобы получить случайное число, используя его метод random().</p>

<pre class="brush: js">console.log(Math.random());
</pre>

<div class="note notecard"><strong>Примечание:</strong> В данном примере и далее мы будем использовать глобальную функцию <a href="/ru/docs/Web/API/Console/log" title="Выводит сообщение в веб-консоль."><code>console.log()</code></a>. Если точнее, то функция <code>console.log()</code> не является частью JavaScript, но она поддерживается многими браузерами для облегчения отладки.</div>

<p>Смотрите <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects" title="en-US/docs/Web/JavaScript/Reference/Global_Objects">JavaScript Reference: Standard built-in objects</a>, чтобы ознакомиться со списком всех встроенных объектов JavaScript.</p>

<p>Каждый объект в JavaScript является экземпляром объекта <code><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object">Object</a></code>, следовательно наследует все его свойства и методы.</p>

<h3 id="Custom_Objects" name="Custom_Objects">Объекты, создаваемые пользователем</h3>

<h4 id="The_Class" name="The_Class">Класс</h4>

<p>JavaScript — это прототипно-ориентированный язык, и в нём нет оператора <code>class</code>, который имеет место в C++ или Java. Иногда это сбивает с толку программистов, привыкших к языкам с оператором <code>class</code>. Вместо этого JavaScript использует функции как конструкторы классов. Объявить класс так же просто как объявить функцию. В примере ниже мы объявляем новый класс Person с пустым конструктором:</p>

<pre class="brush: js">var Person = function () {};
</pre>

<h4 id="The_Object_.28Class_Instance.29" name="The_Object_.28Class_Instance.29">Объект (экземпляр класса)</h4>

<p>Для создания нового экзмепляра объекта <code>obj</code> мы используем оператор <code>new obj</code>, присваивая результат (который имеет тип <code>obj</code>) в переменную.</p>

<p>В примере выше мы определили класс <code>Person</code>. В примере ниже мы создаём два его экземпляра (<code>person1</code> и <code>person2</code>).</p>

<pre class="brush: js">var person1 = new Person();
var person2 = new Person();
</pre>

<div class="note notecard">Ознакомьтесь с <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create" title="Метод Object.create() создаёт новый объект с указанными объектом прототипа и свойствами."><code>Object.create()</code></a>, новым, дополнительным методом инстанцирования, который создаёт неинициализированный экземпляр.</div>

<h4 id="The_Constructor" name="The_Constructor">Конструктор</h4>

<p>Конструктор вызывается в момент создания экземпляра класса (в тот самый момент, когда создается объект). Конструктор является методом класса. В JavaScript функция служит конструктором объекта, поэтому нет необходимости явно определять метод конструктор. Любое действие определенное в конструкторе будет выполненно в момент создания экземпляра класса.</p>

<p>Конструктор используется для задания свойств объекта или для вызова методов, которые подготовят объект к использованию. Добавление методов и их описаний производится с использованием другого синтаксиса, описанного далее в этой статье.</p>

<p>В примере ниже, конструктор класса <code>Person</code> выводит в консоль сообщение в момент создания нового экземпляра <code>Person</code>.</p>

<pre class="brush: js">var Person = function () {
  console.log(&apos;instance created&apos;);
};

var person1 = new Person();
var person2 = new Person();
</pre>

<h4 id="The_Property_.28object_attribute.29" name="The_Property_.28object_attribute.29">Свойство (аттрибут объекта)</h4>

<p>Свойства — это переменные, содержащиеся в классе; каждый экземпляр объекта имеет эти свойства. Свойства устанавливаются в конструкторе (функции) класса, таким образом они создаются для каждого экземпляра.</p>

<p>Ключевое слово <code>this</code>, которое ссылается на текущий объект, позволяет вам работать со свойствами класса. Доступ (чтение и запись) к свойствам снаружи класса осуществляется синтаксисом <code>InstanceName.Property,</code> так же как в C++, Java и некоторых других языках. (Внутри класса для получения и изменения значений свойств используется синтаксис <code>this.Property</code>)</p>

<p>В примере ниже, мы определяем свойство <code>firstName</code> для класса <code>Person</code> при создании экземпляра:</p>

<pre class="brush: js">var Person = function (firstName) {
  this.firstName = firstName;
  console.log(&apos;Person instantiated&apos;);
};

var person1 = new Person(&apos;Alice&apos;);
var person2 = new Person(&apos;Bob&apos;);

// Выводит свойство firstName в консоль
console.log(&apos;person1 is &apos; + person1.firstName); // выведет &quot;person1 is Alice&quot;
console.log(&apos;person2 is &apos; + person2.firstName); // выведет &quot;person2 is Bob&quot;
</pre>

<h4 id="The_methods" name="The_methods">Методы</h4>

<p>Методы — это функции (и определяются как функции), но с другой стороны следуют той же логике, что и свойства. Вызов метода похож на доступ к свойству, но вы добавляете () на конце имени метода, возможно, с аргументами. Чтобы объявить метод, присвойте функцию в именованное свойство свойства <code>prototype</code> класса. Потом вы сможете вызвать метод объекта под тем именем, которое вы присвоили функции.</p>

<p>В примере ниже мы определяем и используем метод <code>sayHello()</code> для класса <code>Person</code>.</p>

<pre class="brush: js">var Person = function (firstName) {
  this.firstName = firstName;
};

Person.prototype.sayHello = function() {
  console.log(&quot;Hello, I&apos;m &quot; + this.firstName);
};

var person1 = new Person(&quot;Alice&quot;);
var person2 = new Person(&quot;Bob&quot;);

// вызываем метод sayHello() класса Person
person1.sayHello(); // выведет &quot;Hello, I&apos;m Alice&quot;
person2.sayHello(); // выведет &quot;Hello, I&apos;m Bob&quot;
</pre>

<p>В JavaScript методы это — обычные объекты функций, связанные с объектом как свойства: это означает, что вы можете вызывать методы &quot;вне контекста&quot;. Рассмотрим следующий пример:</p>

<pre class="brush: js">var Person = function (firstName) {
  this.firstName = firstName;
};

Person.prototype.sayHello = function() {
  console.log(&quot;Hello, I&apos;m &quot; + this.firstName);
};

var person1 = new Person(&quot;Alice&quot;);
var person2 = new Person(&quot;Bob&quot;);
var helloFunction = person1.sayHello;

// выведет &quot;Hello, I&apos;m Alice&quot;
person1.sayHello();

// выведет &quot;Hello, I&apos;m Bob&quot;
person2.sayHello();

// выведет &quot;Hello, I&apos;m undefined&quot; (or fails
// with a TypeError in strict mode)
helloFunction();

// выведет true
console.log(helloFunction === person1.sayHello);

// выведет true
console.log(helloFunction === Person.prototype.sayHello);

// выведет &quot;Hello, I&apos;m Alice&quot;
helloFunction.call(person1);</pre>

<p>Как показывает пример, все ссылки, которые мы имеем на функцию <code>sayHello</code> — <code>person1</code>, <code>Person.prototype</code>, переменная <code>helloFunction</code> и т.д. — ссылаются на одну и ту же функцию. Значение <code>this</code> в момент вызова функции зависит от того, как мы её вызываем. Наиболее часто мы обращаемся к <code>this</code> в выражениях, где мы получаем функцию из свойства объекта — <code>person1.sayHello()</code> — <code>this</code> устанавливается на объект, из которого мы получили функцию (<code>person1</code>), вот почему <code>person1.sayHello()</code> использует имя &quot;Alice&quot;, а <code>person2.sayHello()</code> использует имя &quot;Bob&quot;. Но если вызов будет совершён иначе, то <code>this</code> будет иным: вызов <code>this</code> из переменной — <code>helloFunction()</code> — установит <code>this</code> на глобальный объект (<code>window</code> в браузерах). Так как этот объект (вероятно) не имеет свойства <code>firstName</code>, функция выведет &quot;Hello, I&apos;m undefined&quot; (так произойдёт в нестрогом режиме; в <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode">strict mode</a> всё будет иначе (ошибка), не будем сейчас вдаваться в подробности, чтобы избежать путаницы). Или мы можем указать <code>this</code> явно с помощью <code>Function#call</code> (или <code>Function#apply</code>) как показано в конце примера.</p>

<div class="note notecard"><strong>Примечание:</strong> Смотрите подробнее о <code>this</code> в  <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/call" title="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call">Function#call</a> и <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" title="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply">Function#apply</a></div>

<h4 id="Inheritance" name="Inheritance">Наследование</h4>

<p>Наследование — это способ создать класс как специализированную версию одного или нескольких классов (JavaScript поддерживает только одиночное наследование). Специализированный класс, как правило, называют потомком, а другой класс родителем. В JavaScript наследование осуществляется присвоением экземпляра класса родителя классу потомку. В современных браузерах вы можете реализовать наследование с помощью <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Classical_inheritance_with_Object.create" title="/en-US/docs/JavaScript/Reference/Global_Objects/Object/create#Classical_inheritance_with_Object.create">Object.create</a>.</p>

<div class="note notecard"><strong>Примечание:</strong> JavaScript не обнаружит <code>prototype.constructor</code> класса потомка (смотрите <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype">Object.prototype</a>) так что мы должны указать его вручную. Смотрите вопрос &quot;<a href="http://stackoverflow.com/questions/8453887/why-is-it-necessary-to-set-the-prototype-constructor">Why is it necessary to set the prototype constructor?</a>&quot; на Stackoverflow.</div>

<p>В примере ниже мы определяем класс <code>Student</code> как потомка класса <code>Person</code>. Потом мы переопределяем метод <code>sayHello()</code> и добавляем метод <code>addGoodBye()</code>.</p>

<pre class="brush: js">// Определяем конструктор Person
var Person = function(firstName) {
  this.firstName = firstName;
};

// Добавляем пару методов в Person.prototype
Person.prototype.walk = function(){
  console.log(&quot;I am walking!&quot;);
};

Person.prototype.sayHello = function(){
  console.log(&quot;Hello, I&apos;m &quot; + this.firstName);
};

// Определяем конструктор Student
function Student(firstName, subject) {
  // Вызываем конструктор родителя, убедившись (используя Function#call)
  // что &quot;this&quot; в момент вызова установлен корректно
  Person.call(this, firstName);

  // Инициируем свойства класса Student
  this.subject = subject;
};

// Создаём объект Student.prototype, который наследуется от Person.prototype.
// Примечание: Рспространённая ошибка здесь, это использование &quot;new Person()&quot;, чтобы создать
// Student.prototype. Это неверно по нескольким причинам, не в последнюю очередь
// потому, что нам нечего передать в Person в качестве аргумента &quot;firstName&quot;
// Правильное место для вызова Person показано выше, где мы вызываем
// его в конструкторе Student.
Student.prototype = Object.create(Person.prototype); // Смотрите примечание выше

// Устанавливаем свойство &quot;constructor&quot; для ссылки на класс Student
Student.prototype.constructor = Student;

// Заменяем метод &quot;sayHello&quot;
Student.prototype.sayHello = function(){
  console.log(&quot;Hello, I&apos;m &quot; + this.firstName + &quot;. I&apos;m studying &quot;
              + this.subject + &quot;.&quot;);
};

// Добавляем метод &quot;sayGoodBye&quot;
Student.prototype.sayGoodBye = function(){
  console.log(&quot;Goodbye!&quot;);
};

// Пример использования:
var student1 = new Student(&quot;Janet&quot;, &quot;Applied Physics&quot;);
student1.sayHello();   // &quot;Hello, I&apos;m Janet. I&apos;m studying Applied Physics.&quot;
student1.walk();       // &quot;I am walking!&quot;
student1.sayGoodBye(); // &quot;Goodbye!&quot;

// Проверяем, что instanceof работает корректно
console.log(student1 instanceof Person);  // true
console.log(student1 instanceof Student); // true
</pre>

<p>Относительно строки <code>Student.prototype = Object.create(Person.prototype);</code>: В старых движках JavaScript, в которых нет  <code><a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" title="Object.create">Object.create</a></code> можно использовать полифилл (ещё известный как &quot;shim&quot;) или функцию которая достигает тех же результатов, такую как:</p>

<pre class="brush: js">function createObject(proto) {
    function ctor() { }
    ctor.prototype = proto;
    return new ctor();
}

// Пример использования:
Student.prototype = createObject(Person.prototype);
</pre>

<div class="note notecard"><strong>Примечание:</strong> Смотрите <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create" title="Object.create">Object.create</a> для более подробной информации, и shim для реализации на старых движках.</div>

<h4 id="Encapsulation" name="Encapsulation">Инкапсуляция</h4>

<p>В примере выше классу <code>Student</code> нет необходимости знать о реализации метода <code>walk()</code> класса <code>Person</code>, но он может его использовать; Класс <code>Student</code> не должен явно определять этот метод, пока мы не хотим его изменить. Это называется <strong>инкапсуляция</strong>, благодаря чему каждый класс собирает данные и методы в одном блоке.</p>

<p>Сокрытие информации распространённая особенность, часто реализуемая в других языках программирования как приватные и защищённые методы/свойства. Однако в JavaScript можно лишь имитировать нечто подобное, это не является необходимым требованием объектно-ориентированного программирования.<a href="#cite-2"><sup>2</sup></a></p>

<h4 id="Abstraction" name="Abstraction">Абстракция</h4>

<p>Абстракция это механизм который позволяет смоделировать текущий фрагмент рабочей проблемы, с помощью наследования (специализации) или композиции. JavaScript достигает специализации наследованием, а композиции возможностью экземплярам класса быть значениями атрибутов других объектов.</p>

<p>В JavaScript класс <code>Function</code> наследуется от класса <code>Object</code> (это демонстрирует специализацию), а свойство <code>Function.prototype</code> это экземпляр класса <code>Object</code> (это демонстрирует композицию).</p>

<pre class="brush: js">var foo = function () {};

// выведет &quot;foo is a Function: true&quot;
console.log(&apos;foo is a Function: &apos; + (foo instanceof Function));

// выведет &quot;foo.prototype is an Object: true&quot;
console.log(&apos;foo.prototype is an Object: &apos; + (foo.prototype instanceof Object));</pre>

<h4 id="Polymorphism" name="Polymorphism">Полиморфизм</h4>

<p>Так как все методы и свойства определяются внутри свойства <code>prototype</code>, различные классы могут определять методы с одинаковыми именами; методы находятся в области видимости класса в котором они определены, пока два класса не имеют связи родитель-потомок (например, один наследуется от другого в цепочке наследований).</p>

<h2 id="Notes" name="Notes">Примечания</h2>

<p>Это не все способы которыми можно реализовать объектно-ориентированное программирование в JavaScript, который очень гибок в этом отношении. Также способы рассмотренные здесь не отражают всех возможностей JavaScript и не подражают реализации теории объектов в других языках.</p>

<p>Существуют другие способы, которые реализуют ещё более продвинутое объектно-ориентированное программирование на JavaScript, но они выходят за рамки этой вводной статьи.</p>

<h2 id="References" name="References">Ссылки</h2>

<ol>
 <li><a name="cite-1"></a>Wikipedia. &quot;<a href="http://en.wikipedia.org/wiki/Object-oriented_programming">Object-oriented programming</a>&quot;</li>
 <li><a name="cite-2"></a>Wikipedia. &quot;<a href="http://en.wikipedia.org/wiki/Encapsulation_%28object-oriented_programming%29">Encapsulation (object-oriented programming)</a>&quot;</li>
</ol>
