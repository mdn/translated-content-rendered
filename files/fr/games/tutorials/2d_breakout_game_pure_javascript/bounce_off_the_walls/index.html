---
title: Faire rebondir la balle sur les murs
slug: >-
  Games/Workflows/2D_Breakout_game_pure_JavaScript/Faire_rebondir_la_balle_sur_les_murs
tags:
  - Animation
  - Canvas
  - Débutant
  - Exemple
  - JavaScript
  - Jeux
  - Tuto
  - Tutoriel
  - detection
  - graphique
translation_of: Games/Tutorials/2D_Breakout_game_pure_JavaScript/Bounce_off_the_walls
---
<div><section class="Quick_links" id="Quick_Links">
  <ol>
    <li class="toggle">
        <details>
            <summary>Introduction</summary>
            <ol>
              <li><a href="/fr/docs/Games/Introduction">Introduction</a></li>
              <li><a href="/fr/docs/Games/Anatomy">Anatomie d&apos;un jeu vidéo</a></li>
              <li><a href="/fr/docs/Games/Examples">Exemples</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>API pour le développement de jeux</summary>
            <ol>
              <li><a href="/fr/docs/Web/API/Canvas_API">Canvas</a></li>
              <li><a href="/fr/docs/Web/CSS">CSS</a></li>
              <li><a href="/fr/docs/Web/Apps/Fundamentals/User_notifications/Full_screen_api">Full Screen (plein écran)</a></li>
              <li><a href="/fr/docs/Web/API/Gamepad_API">Gamepad (manette)</a></li>
              <li><a href="/fr/docs/Web/API/IndexedDB_API">IndexedDB</a></li>
              <li><a href="/fr/docs/Web/JavaScript">JavaScript</a></li>
              <li><a href="/fr/docs/Web/API/Pointer_Lock_API">Pointer Lock (verrou de pointeur)</a></li>
              <li><a href="/fr/docs/Web/SVG">SVG</a></li>
              <li><a href="/fr/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">Typed Arrays (tableaux typés)</a></li>
              <li><a href="/fr/docs/Web/API/Web_Audio_API">Web Audio</a></li>
              <li><a href="/fr/docs/Web/API/WebGL_API">WebGL</a></li>
              <li><a href="/fr/docs/Web/API/WebRTC_API">WebRTC</a></li>
              <li><a href="/fr/docs/Web/API/WebSockets_API">WebSockets</a></li>
              <li><a href="/fr/docs/Web/API/WebVR_API">WebVR (réalité virtuelle)</a></li>
              <li><a href="/fr/docs/Web/API/Web_Workers_API">Web Workers</a></li>
              <li><a href="/fr/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>Techniques</summary>
            <ol>
              <li><a href="/fr/docs/Games/Techniques/Async_scripts">Utiliser des scripts asynchrones pour asm.js</a></li>
              <li><a href="/fr/docs/Web/Apps/Developing/Optimizing_startup_performance">Optimiser les performances de démarrage</a></li>
              <li><a href="/fr/docs/Games/Techniques/WebRTC_data_channels">Utiliser WebRTC - canaux de données pair-à-pair</a></li>
              <li><a href="/fr/docs/Games/Techniques/Efficient_animation_for_web_games">Animation efficace pour un jeu internet</a></li>
              <li><a href="/fr/docs/Games/Techniques/Audio_for_Web_Games">Audio pour les jeux web</a></li>
              <li><a href="/fr/docs/Games/Techniques/2D_collision_detection">Détection de collision 2D</a></li>
              <li><a href="/fr/docs/Games/Techniques/Tilemaps">Carreaux et carrelages</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>Jeux 3D sur le Web</summary>
            <ol>
              <li><a href="/fr/docs/Games/Techniques/3D_on_the_web">Aperçu des jeux 3D sur le Web</a></li>
              <li><a href="/fr/docs/Games/Techniques/3D_on_the_web/Basic_theory">Théorie de base sur la 3D</a></li>
              <li><a href="/fr/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_A-Frame">Construire une démo avec A-Frame</a></li>
              <li><a href="/fr/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Babylon.js">Construire une démo avec Babylon.js</a></li>
              <li><a href="/fr/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas">Construire une démo avec PlayCanvas</a></li>
              <li><a href="/fr/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js">Construire une démo avec Three.js</a></li>
              <li><a href="/fr/docs/Games/Techniques/3D_on_the_web/WebVR">WebVR (réalité virtuelle)</a></li>
              <li><a href="/fr/docs/Games/Techniques/3D_collision_detection">Détection de collision en 3D</a></li>
              <li><a href="/fr/docs/Games/Techniques/3D_collision_detection/Bounding_volume_collision_detection_with_THREE.js">Détection de collision de volumes avec THREE.js</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>Mise en place des contrôle du jeu</summary>
            <ol>
              <li><a href="/fr/docs/Games/Techniques/Control_mechanisms">Aperçu des mécanismes de contrôle du jeu</a></li>
              <li><a href="/fr/docs/Games/Techniques/Control_mechanisms/Mobile_touch">Commandes tactiles mobiles</a></li>
              <li><a href="/fr/docs/Games/Techniques/Control_mechanisms/Desktop_with_mouse_and_keyboard">Commandes à la souris et au clavier</a></li>
              <li><a href="/fr/docs/Games/Techniques/Control_mechanisms/Desktop_with_gamepad">Commandes à la manette</a></li>
              <li><a href="/fr/docs/Games/Techniques/Control_mechanisms/Other">Contrôles non conventionnels</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>Tutoriels</summary>
            <ol>
              <li><a href="/fr/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript">Jeu de casse-briques 2D avec du pur JavaScript</a></li>
              <li><a href="/fr/docs/Games/Tutorials/2D_breakout_game_Phaser">Jeu de casse-tête 2D avec Phaser</a></li>
              <li><a href="/fr/docs/Games/Tutorials/HTML5_Gamedev_Phaser_Device_Orientation">Jeu de labyrinthe 2D avec orientation du périphérique</a></li>
              <li><a href="https://mozdevs.github.io/html5-games-workshop/en/guides/platformer/start-here/">Jeu de plateforme 2D avec Phaser</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>Publication de jeux</summary>
            <ol>
              <li><a href="/fr/docs/Games/Publishing_games">Aperçu des outils de publication des jeux</a></li>
              <li><a href="/fr/docs/Games/Publishing_games/Game_distribution">Distribution des jeux</a></li>
              <li><a href="/fr/docs/Games/Publishing_games/Game_promotion">Promotion des jeux</a></li>
              <li><a href="/fr/docs/Games/Publishing_games/Game_monetization">Monétisation des jeux</a></li>
            </ol>
        </details>
    </li>
  </ol>
</section></div>

<div></div>

<div class="prevnext" style="text-align: right;">
    <p><a href="/fr/docs/Games/Workflows/2D_Breakout_game_pure_JavaScript/Move_the_ball" style="float: left;" class="button">« Précédent</a><a href="/fr/docs/Games/Workflows/2D_Breakout_game_pure_JavaScript/Paddle_et_contr%C3%B4le_clavier" class="button">Suivant  »</a></p>
</div>

<div class="summary">
<p>C&apos;est la <strong>3<sup>ème</sup> étape sur</strong> 10 de ce <a href="https://developer.mozilla.org/fr/docs/Games/Workflows/2D_Breakout_game_pure_JavaScript">tutoriel Gamedev Canvas</a>. Vous pouvez retrouver le code source de cette leçon sur <a class="external external-icon" href="https://github.com/end3r/Gamedev-Canvas-workshop/blob/gh-pages/lesson01.html" rel="noopener">Gamedev-Canvas-workshop/lesson3.html</a>.</p>
</div>

<p>C&apos;est agréable de voir notre balle bouger, mais elle disparaît rapidement de l&apos;écran, ce qui limite le plaisir que nous pouvons avoir avec elle ! Pour y pallier, nous allons mettre en place une détection de collision très simple (qui sera expliquée plus tard en détail) pour faire rebondir la balle sur les quatre bords de la toile.</p>

<h2 id="Détection_des_collisions">Détection des collisions</h2>

<p>Pour détecter la collision, nous vérifierons si la balle touche (entre en collision avec) le mur et, si c&apos;est le cas, nous modifierons la direction de son mouvement en conséquence.<br>
 <br>
 Pour faciliter les calculs, nous allons définir une variable appelée <code>ballRadius</code> qui contiendra le rayon du cercle dessiné et sera utilisée pour les calculs. Ajoutez cette variable à votre code, quelque part en dessous des déclarations de variables existantes :<br>
  </p>

<pre class="brush: js notranslate">var ballRadius = 10;</pre>

<p>Mettez maintenant à jour la ligne qui dessine la balle à l&apos;intérieur de la fonction <code>drawBall()</code> :</p>

<pre class="brush: js notranslate">ctx.arc(x, y, ballRadius, 0, Math.PI*2);</pre>

<h3 id="Rebondir_en_haut_et_en_bas">Rebondir en haut et en bas</h3>

<p>Il y a 4 murs en tout mais nous allons d&apos;abord nous pencher sur le mur du haut. Nous devons, à chaque rafraichissement du canvas, regarder si la balle touche le bord du haut. Si c&apos;est le cas, alors nous devons inverser la direction de la balle pour créer un effet de limite de zone de jeu. Il ne faut surtout pas oublier que le point d&apos;origine est en haut à gauche ! Nous pouvons donc écrire :</p>

<pre class="brush: js notranslate">if(y + dy &lt; 0) {
    dy = -dy;
}</pre>

<p>Si la valeur y de la position de la balle est inférieure à zéro, changez la direction du mouvement sur l&apos;axe y en le rendant égal à son inverse. Si la balle se déplaçait vers le haut à une vitesse de 2 pixels par image, elle se déplacera maintenant &quot;vers le haut&quot; à une vitesse de -2 pixels, ce qui équivaut en fait à se déplacer vers le bas à une vitesse de 2 pixels par image.<br>
 <br>
 Le code ci-dessus traite du rebondissement de la balle sur le bord supérieur, alors traitons maintenant le bord inférieur :</p>

<pre class="brush: js notranslate">if(y + dy &gt; canvas.height) {
    dy = -dy;
}</pre>

<p>Si la position en y de la balle est supérieure à  la hauteur du canvas (soit 480 pixels dans cette leçon) on inverse encore la vitesse de la balle.</p>

<p>On peut rassembler les deux conditions en une grâce au &quot;ou&quot; qui s&apos;écrit || en JavaScript :</p>

<pre class="brush: js notranslate">if(y + dy &gt; canvas.height || y + dy &lt; 0) {
    dy = -dy;
}</pre>

<p>Si une des deux conditions est vérifiée, alors la vitesse est inversée. Essayez de créer votre propre code pour la gauche et la droite avant de passer à la prochaine sous-partie. Vous verrez que le principe est le même.</p>

<h3 id="Rebondir_à_gauche_et_à_droite">Rebondir à gauche et à droite</h3>

<p>Nous avons couvert les bords supérieur et inférieur, alors pensons à ceux de gauche et de droite. C&apos;est très similaire en fait, il suffit de répéter les instructions pour <code>x</code> au lieu de <code>y</code> :</p>

<pre class="brush: js notranslate">if(x + dx &gt; canvas.width || x + dx &lt; 0) {
    dx = -dx;
}

if(y + dy &gt; canvas.height || y + dy &lt; 0) {
    dy = -dy;
}</pre>

<p>À ce stade, vous devez insérer le bloc de code ci-dessus dans la fonction draw(), juste avant l&apos;accolade de fermeture.</p>

<h3 id="La_balle_disparaît_toujours!">La balle disparaît toujours!</h3>

<p>Testez votre code à ce stade, et vous serez impressionné — nous avons maintenant une balle qui rebondit sur les quatre bords de la toile ! Mais nous avons un autre problème — lorsque la balle frappe un mur, elle s&apos;y enfonce légèrement avant de changer de direction :</p>

<p><img alt src="https://mdn.mozillademos.org/files/10432/ball-in-wall.png" style="display: block; height: 320px; margin: 0px auto; width: 480px;"></p>

<p>C&apos;est parce que nous calculons le point de collision entre le mur et le centre de la balle, alors que nous devrions le faire pour sa circonférence. La balle devrait rebondir juste après avoir touché le mur, et non pas lorsqu&apos;elle est déjà à mi-chemin dans le mur, alors ajustons un peu nos déclarations pour inclure cela. Mettez à jour le dernier code que vous avez ajouté :</p>

<pre class="brush: js notranslate">if(x + dx &gt; canvas.width-ballRadius || x + dx &lt; ballRadius) {
    dx = -dx;
}
if(y + dy &gt; canvas.height-ballRadius || y + dy &lt; ballRadius) {
    dy = -dy;
}</pre>

<p>Lorsque la distance entre le centre de la balle et le bord du mur est exactement la même que le rayon de la balle, cela change la direction du mouvement. Soustraire le rayon de la largeur d&apos;un bord et l&apos;ajouter à l&apos;autre nous donne l&apos;impression d&apos;une détection de collision correcte — la balle rebondit sur les murs comme elle devrait le faire.</p>

<h2 id="Comparez_votre_code">Comparez votre code</h2>

<p>Vérifions encore une fois le code fini pour cette partie par rapport à ce que vous avez, et jouons une partie :</p>

<p><iframe frameborder="0" height="395" src="https://jsfiddle.net/end3r/redj37dc/embedded/" width="100%"></iframe></p>

<div class="note notecard">
<p><strong>Exercice</strong>: essayez de changer la couleur de la balle à chaque fois que celle-ci tape un mur.</p>
</div>

<h2 id="Dans_le_prochain_chapitre">Dans le prochain chapitre</h2>

<p>Nous sommes maintenant arrivés au stade où notre balle se déplace et reste sur le plateau de jeu. Dans le quatrième chapitre, nous examinerons la mise en place d&apos;une raquette contrôlable - voir<a href="https://developer.mozilla.org/en-US/docs/Games/Workflows/Breakout_game_from_scratch/Paddle_and_keyboard_controls"> Raquette et contrôle au clavier</a>. {PreviousNext(&quot;Games/Workflows/2D_Breakout_game_pure_JavaScript/Move_the_ball&quot;, &quot;Games/Workflows/2D_Breakout_game_pure_JavaScript/Paddle_et_contr%C3%B4le_clavier&quot;)}}</p>
