---
title: Finitions
slug: Games/Tutorials/2D_Breakout_game_pure_JavaScript/Finishing_up
tags:
  - Canevas
  - Débutant
  - JavaScript
  - Jeux
  - Tutoriel
  - requestAnimationFrame
  - vies
translation_of: Games/Tutorials/2D_Breakout_game_pure_JavaScript/Finishing_up
original_slug: Games/Workflows/2D_Breakout_game_pure_JavaScript/finitions
---
<div><section class="Quick_links" id="Quick_Links">
  <ol>
    <li class="toggle">
        <details>
            <summary>Introduction</summary>
            <ol>
              <li><a href="/fr/docs/Games/Introduction">Introduction</a></li>
              <li><a href="/fr/docs/Games/Anatomy">Anatomie d&apos;un jeu vidéo</a></li>
              <li><a href="/fr/docs/Games/Examples">Exemples</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>API pour le développement de jeux</summary>
            <ol>
              <li><a href="/fr/docs/Web/API/Canvas_API">Canvas</a></li>
              <li><a href="/fr/docs/Web/CSS">CSS</a></li>
              <li><a href="/fr/docs/Web/Apps/Fundamentals/User_notifications/Full_screen_api">Full Screen (plein écran)</a></li>
              <li><a href="/fr/docs/Web/API/Gamepad_API">Gamepad (manette)</a></li>
              <li><a href="/fr/docs/Web/API/IndexedDB_API">IndexedDB</a></li>
              <li><a href="/fr/docs/Web/JavaScript">JavaScript</a></li>
              <li><a href="/fr/docs/Web/API/Pointer_Lock_API">Pointer Lock (verrou de pointeur)</a></li>
              <li><a href="/fr/docs/Web/SVG">SVG</a></li>
              <li><a href="/fr/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">Typed Arrays (tableaux typés)</a></li>
              <li><a href="/fr/docs/Web/API/Web_Audio_API">Web Audio</a></li>
              <li><a href="/fr/docs/Web/API/WebGL_API">WebGL</a></li>
              <li><a href="/fr/docs/Web/API/WebRTC_API">WebRTC</a></li>
              <li><a href="/fr/docs/Web/API/WebSockets_API">WebSockets</a></li>
              <li><a href="/fr/docs/Web/API/WebVR_API">WebVR (réalité virtuelle)</a></li>
              <li><a href="/fr/docs/Web/API/Web_Workers_API">Web Workers</a></li>
              <li><a href="/fr/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>Techniques</summary>
            <ol>
              <li><a href="/fr/docs/Games/Techniques/Async_scripts">Utiliser des scripts asynchrones pour asm.js</a></li>
              <li><a href="/fr/docs/Web/Apps/Developing/Optimizing_startup_performance">Optimiser les performances de démarrage</a></li>
              <li><a href="/fr/docs/Games/Techniques/WebRTC_data_channels">Utiliser WebRTC - canaux de données pair-à-pair</a></li>
              <li><a href="/fr/docs/Games/Techniques/Efficient_animation_for_web_games">Animation efficace pour un jeu internet</a></li>
              <li><a href="/fr/docs/Games/Techniques/Audio_for_Web_Games">Audio pour les jeux web</a></li>
              <li><a href="/fr/docs/Games/Techniques/2D_collision_detection">Détection de collision 2D</a></li>
              <li><a href="/fr/docs/Games/Techniques/Tilemaps">Carreaux et carrelages</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>Jeux 3D sur le Web</summary>
            <ol>
              <li><a href="/fr/docs/Games/Techniques/3D_on_the_web">Aperçu des jeux 3D sur le Web</a></li>
              <li><a href="/fr/docs/Games/Techniques/3D_on_the_web/Basic_theory">Théorie de base sur la 3D</a></li>
              <li><a href="/fr/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_A-Frame">Construire une démo avec A-Frame</a></li>
              <li><a href="/fr/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Babylon.js">Construire une démo avec Babylon.js</a></li>
              <li><a href="/fr/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas">Construire une démo avec PlayCanvas</a></li>
              <li><a href="/fr/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js">Construire une démo avec Three.js</a></li>
              <li><a href="/fr/docs/Games/Techniques/3D_on_the_web/WebVR">WebVR (réalité virtuelle)</a></li>
              <li><a href="/fr/docs/Games/Techniques/3D_collision_detection">Détection de collision en 3D</a></li>
              <li><a href="/fr/docs/Games/Techniques/3D_collision_detection/Bounding_volume_collision_detection_with_THREE.js">Détection de collision de volumes avec THREE.js</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>Mise en place des contrôle du jeu</summary>
            <ol>
              <li><a href="/fr/docs/Games/Techniques/Control_mechanisms">Aperçu des mécanismes de contrôle du jeu</a></li>
              <li><a href="/fr/docs/Games/Techniques/Control_mechanisms/Mobile_touch">Commandes tactiles mobiles</a></li>
              <li><a href="/fr/docs/Games/Techniques/Control_mechanisms/Desktop_with_mouse_and_keyboard">Commandes à la souris et au clavier</a></li>
              <li><a href="/fr/docs/Games/Techniques/Control_mechanisms/Desktop_with_gamepad">Commandes à la manette</a></li>
              <li><a href="/fr/docs/Games/Techniques/Control_mechanisms/Other">Contrôles non conventionnels</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>Tutoriels</summary>
            <ol>
              <li><a href="/fr/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript">Jeu de casse-briques 2D avec du pur JavaScript</a></li>
              <li><a href="/fr/docs/Games/Tutorials/2D_breakout_game_Phaser">Jeu de casse-tête 2D avec Phaser</a></li>
              <li><a href="/fr/docs/Games/Tutorials/HTML5_Gamedev_Phaser_Device_Orientation">Jeu de labyrinthe 2D avec orientation du périphérique</a></li>
              <li><a href="https://mozdevs.github.io/html5-games-workshop/en/guides/platformer/start-here/">Jeu de plateforme 2D avec Phaser</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>Publication de jeux</summary>
            <ol>
              <li><a href="/fr/docs/Games/Publishing_games">Aperçu des outils de publication des jeux</a></li>
              <li><a href="/fr/docs/Games/Publishing_games/Game_distribution">Distribution des jeux</a></li>
              <li><a href="/fr/docs/Games/Publishing_games/Game_promotion">Promotion des jeux</a></li>
              <li><a href="/fr/docs/Games/Publishing_games/Game_monetization">Monétisation des jeux</a></li>
            </ol>
        </details>
    </li>
  </ol>
</section></div>

<div></div>

<div class="prevnext" style="text-align: right;">
    <p><a href="/fr/docs/Games/Workflows/2D_Breakout_game_pure_JavaScript/Mouse_controls" style="float: left;" class="button">« Précédent</a><br></p>
</div>

<div class="summary">
<p>C&apos;est la dernière étape de ce <a href="https://developer.mozilla.org/en-US/docs/Games/Workflows/Breakout_game_from_scratch">tutoriel Gamedev Canvas</a>. Vous pouvez trouver le code source tel qu&apos;il devrait être après avoir terminé cette leçon à l&apos;adresse <a href="https://github.com/end3r/Gamedev-Canvas-workshop/blob/gh-pages/lesson10.html">Gamedev-Canvas-workshop/lesson10.html</a>.</p>
</div>

<p><span class="seoSummary">Il y a toujours des améliorations possibles pour tous les jeux que nous créons. Par exemple, nous pouvons offrir plus d&apos;une vie au joueur. Il peut faire une ou deux erreurs et être encore capable de terminer le jeu. Nous pourrions également améliorer le rendu visuel du jeu.</span></p>

<h2 id="Donner_des_vies_au_joueur">Donner des vies au joueur</h2>

<p>Mettre en œuvre des vies est assez simple. Ajoutons d&apos;abord une variable pour stocker le nombre de vies à l&apos;endroit où nous avons déclaré nos autres variables :</p>

<pre class="brush: js notranslate">var lives = 3;</pre>

<p>L&apos;affichage du compteur de vie est similaire à celui du compteur de points — ajoutez la fonction suivante à votre code, sous la fonction <code>drawScore()</code> :</p>

<pre class="brush: js notranslate">function drawLives() {
    ctx.font = &quot;16px Arial&quot;;
    ctx.fillStyle = &quot;#0095DD&quot;;
    ctx.fillText(&quot;Lives: &quot;+lives, canvas.width-65, 20);
}</pre>

<p>Au lieu de mettre immédiatement fin au jeu, nous allons réduire le nombre de vies jusqu&apos;à ce qu&apos;il n&apos;y en ait plus. Nous pouvons également réinitialiser les positions du ballon et de la raquette lorsque le joueur commence sa prochaine vie. Ainsi, dans la fonction <code>draw()</code>, remplacez les trois lignes suivantes :</p>

<pre class="brush: js notranslate">alert(&quot;GAME OVER&quot;);
document.location.reload();
clearInterval(interval); // Needed for Chrome to end game</pre>



<p>Nous pouvons ainsi y ajouter une logique un peu plus complexe, comme indiqué ci-dessous :</p>

<pre class="brush: js notranslate">lives--;
if(!lives) {
    alert(&quot;GAME OVER&quot;);
    document.location.reload();
    clearInterval(interval); // Needed for Chrome to end game
}
else {
    x = canvas.width/2;
    y = canvas.height-30;
    dx = 2;
    dy = -2;
    paddleX = (canvas.width-paddleWidth)/2;
}</pre>

<p>Maintenant, quand la balle frappe le bord inférieur de l&apos;écran, nous soustrayons une vie de la variable <code>lives</code>. S&apos;il n&apos;y a plus de vies, la partie est perdue ; s&apos;il reste encore des vies, alors la position de la balle et la raquette sont remises à zéro, ainsi que le mouvement de la balle.</p>

<h3 id="Afficher_le_compteur_de_vies">Afficher le compteur de vies</h3>

<p>Maintenant, vous devez ajouter un appel à <code>drawLives()</code> dans la fonction <code>draw()</code> et l&apos;ajouter sous l&apos;appel <code>drawScore()</code>.</p>

<pre class="brush: js notranslate">drawLives();
</pre>

<h2 id="Améliorer_le_rendu_avec_requestAnimationFrame">Améliorer le rendu avec requestAnimationFrame()</h2>

<p>Maintenant, travaillons sur quelque chose qui n&apos;est pas lié à la mécanique du jeu, mais à la façon dont il est rendu. <a href="/fr/docs/Web/API/Window/requestAnimationFrame"><code>requestAnimationFrame</code></a> aide le navigateur à rendre le jeu mieux que la cadence fixe que nous avons actuellement mise en place en utilisant <a href="/fr/docs/Web/API/WindowTimers/setInterval"><code>setInterval()</code></a>. Remplacez la ligne suivante :</p>

<pre class="brush: js notranslate">var interval = setInterval(draw, 10);</pre>

<p>avec simplement :</p>

<pre class="brush: js notranslate">draw();</pre>

<p>et supprimez chaque occurence de :</p>

<pre class="brush: js notranslate">clearInterval(interval); // Needed for Chrome to end game
</pre>

<p>Ensuite, tout en bas de la fonction <code>draw()</code> (juste avant l&apos;accolade de fermeture), ajoutez la ligne suivante, ce qui fait que la fonction <code>draw()</code> s&apos;appelle encore et encore :</p>

<pre class="brush: js notranslate">requestAnimationFrame(draw);</pre>

<p>La fonction <code>draw()</code> est maintenant exécutée indéfiniment dans une boucle <code>requestAnimationFrame()</code>, mais au lieu de la cadence fixe de 10 millisecondes, nous redonnons le contrôle de la cadence au navigateur. Il synchronisera la cadence en conséquence et ne n&apos;acutalisera l&apos;affichage que lorsque cela sera nécessaire. Cela permet d&apos;obtenir une boucle d&apos;animation plus efficace et plus fluide que l&apos;ancienne méthode <code>setInterval()</code>.</p>

<h2 id="Comparez_votre_code_your_code">Comparez votre code your code</h2>

<p>C&apos;est tout — la version finale du jeu est prête et prête à être lancée !</p>

<p><iframe frameborder="0" height="395" src="https://jsfiddle.net/raymondjplante/dfh2tpu1/embedded/" width="100%"></iframe></p>

<div class="note notecard">
<p><strong>Exercise</strong>: changer le nombre de vies et l&apos;angle de rebond de la balle sur la raquette.</p>
</div>

<h2 id="Game_over_-_pour_linstant_!">Game over - pour l&apos;instant !</h2>

<p>Vous avez terminé toutes les leçons - félicitations ! À ce stade, vous devriez maintenant connaître les bases de la manipulation des Canevas et la logique des jeux simples en 2D. C&apos;est maintenant le bon moment pour apprendre quelques frameworks et continuer le développement du jeu. Vous pouvez découvrir le pendant de cette série, le <a href="https://developer.mozilla.org/fr/docs/Games/Workflows/2D_breakout_game_Phaser">casse-brique 2D utilisant Phaser</a> ou le <a href="https://developer.mozilla.org/fr/docs/Games/Workflows/HTML5_Gamedev_Phaser_Device_Orientation_FR">tutoriel Cyber Orb</a> construit avec Phaser. Vous pouvez également consulter la section <a href="https://developer.mozilla.org/fr/docs/Jeux">Jeux sur MDN</a> pour vous inspirer et approfondir vos connaissances.</p>

<p>Vous pouvez également revenir à la <a href="https://developer.mozilla.org/fr/docs/Games/Workflows/2D_Breakout_game_pure_JavaScript">page d&apos;accueil</a> de cette série de tutoriels. Amusez-vous bien à coder !</p>

<div class="prevnext" style="text-align: right;">
    <p><a href="/fr/docs/Games/Workflows/2D_Breakout_game_pure_JavaScript/Mouse_controls" style="float: left;" class="button">« Précédent</a><br></p>
</div>
