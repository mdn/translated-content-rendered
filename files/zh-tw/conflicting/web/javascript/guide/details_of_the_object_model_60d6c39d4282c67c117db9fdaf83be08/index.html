---
title: 沒有多重繼承
slug: >-
  conflicting/Web/JavaScript/Guide/Details_of_the_Object_Model_60d6c39d4282c67c117db9fdaf83be08
translation_of: Web/JavaScript/Guide/Details_of_the_Object_Model
translation_of_original: >-
  Web/JavaScript/Guide/Obsolete_Pages/Property_Inheritance_Revisited/No_Multiple_Inheritance
original_slug: Web/JavaScript/Obsolete_Pages/Obsolete_Pages/Obsolete_Pages/再談屬性的繼承/沒有多重繼承
---
<h3 id="沒有多重繼承" name="沒有多重繼承">沒有多重繼承</h3>
<p>部分物件導向語言允許多重繼承。也就是說，物件可以從互不相關的親物件繼承屬性和值。不過 JavaScript 並不支援多重繼承。</p>
<p>屬性值的繼承發生在執行時期，由 JavaScript 搜尋物件的原型鏈以找出繼承值。由於物件只有單一的已連結原型，因此 JavaScript 並不能從多於一個以上的原型鏈中動態的繼承。</p>
<p>在 JavaScript 中，建構子函數的內部可以有很多個其他的建構子函數的呼叫。如此可提供多重繼承的假象。例如，思考下面的語句︰</p>
<pre>function Hobbyist (hobby) {
   this.hobby = hobby || &quot;scuba&quot;;
}

function Engineer (name, projs, mach, hobby) {
   this.base1 = WorkerBee;
   this.base1(name, &quot;engineering&quot;, projs);
   this.base2 = Hobbyist;
   this.base2(hobby);
   this.machine = mach || &quot;&quot;;
}
Engineer.prototype = new WorkerBee;

dennis = new Engineer(&quot;Doe, Dennis&quot;, [&quot;collabra&quot;], &quot;hugo&quot;)
</pre>
<p>接著假定 <code>WorkerBee</code> 的定義使用的是本章先前的內容。在這個情況下，<code>dennis</code> 物件就有了這些屬性︰</p>
<pre>dennis.name == &quot;Doe, Dennis&quot;
dennis.dept == &quot;engineering&quot;
dennis.projects == [&quot;collabra&quot;]
dennis.machine == &quot;hugo&quot;
dennis.hobby == &quot;scuba&quot;
</pre>
<p>所以 <code>dennis</code> 從 <code>Hobbyist</code> 建構子中得到了 <code>hobby</code> 的屬性。然而，假定你稍後把新的屬性加入到 <code>Hobbyist</code> 建構子的原型︰</p>
<pre>Hobbyist.prototype.equipment = [&quot;mask&quot;, &quot;fins&quot;, &quot;regulator&quot;, &quot;bcd&quot;]
</pre>
<p><code>dennis</code> 物件並未繼承到這個新的屬性。</p>
<div class="noinclude">
<p></p><div style="text-align: right;" class="prevnext">
    <p><a style="float: left;" href="/zh-TW/docs/Core_JavaScript_1.5_教學:再談屬性的繼承:建構子中的全域資訊" class="button">« 前頁</a><a href="/zh-TW/docs/Core_JavaScript_1.5_教學:LiveConnect_概要" class="button">次頁  »</a></p>
</div><p></p>
</div>

<p></p>
